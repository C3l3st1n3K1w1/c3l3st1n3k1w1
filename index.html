<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Coffee Game – Multigame Lobby</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@300;400;600;700&display=swap" rel="stylesheet" />
  <style>
    * { box-sizing: border-box; }
    :root {
      --espresso: #2a1f1f;
      --roast: #3b2f2f;
      --medium: #4a3a2f;
      --latte: #6b4f3a;
      --cream: #d7c4a3;
      --foam: #f5eee6;
      --accent: #f2b36f;
      --accent-soft: #f7cfa0;
      --border-soft: #5a4636;
    }
    body {
      margin: 0;
      padding: 0;
      font-family: "Nunito", system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      background: radial-gradient(circle at top, #4a3a2f 0%, #2a1f1f 45%, #1b1412 100%);
      color: var(--foam);
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
    }
    h1 {
      margin: 16px 0 8px;
      font-size: 26px;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      color: var(--foam);
      text-shadow: 0 2px 4px rgba(0,0,0,0.6);
    }
    .subtitle {
      font-size: 12px;
      color: var(--cream);
      opacity: 0.8;
      margin-bottom: 8px;
    }
    .container {
      width: 100%;
      max-width: 1040px;
      padding: 16px;
      position: relative;
    }
    .card {
      background: rgba(59,47,47,0.9);
      border-radius: 14px;
      border: 1px solid var(--border-soft);
      box-shadow: 0 10px 30px rgba(0,0,0,0.45);
      padding: 16px;
      backdrop-filter: blur(10px);
    }
    .row {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      margin-bottom: 12px;
    }
    .col {
      flex: 1;
      min-width: 260px;
    }
    .section-title {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: var(--cream);
      margin-bottom: 4px;
      opacity: 0.8;
    }
    input, button, textarea {
      width: 100%;
      padding: 8px 10px;
      border-radius: 999px;
      border: 1px solid var(--border-soft);
      background: rgba(26,19,19,0.9);
      color: var(--foam);
      font-size: 14px;
      outline: none;
      transition: border-color 0.15s, box-shadow 0.15s, background 0.15s;
    }
    textarea {
      border-radius: 10px;
      resize: none;
    }
    input:focus, textarea:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 1px rgba(242,179,111,0.5);
      background: rgba(26,19,19,1);
    }
    button {
      cursor: pointer;
      border-radius: 999px;
      border: 1px solid var(--accent);
      background: linear-gradient(135deg, var(--accent) 0%, var(--accent-soft) 100%);
      color: #3b2f2f;
      font-weight: 600;
      text-shadow: 0 1px 0 rgba(255,255,255,0.4);
    }
    button:disabled {
      opacity: 0.4;
      cursor: default;
      background: rgba(80,60,50,0.8);
      border-color: rgba(120,90,70,0.8);
      color: var(--cream);
      text-shadow: none;
    }
    .panel {
      border-radius: 10px;
      border: 1px solid var(--border-soft);
      background: rgba(26,19,19,0.9);
      padding: 8px;
      min-height: 80px;
    }
    #profileCardHost, #profileCardJoin {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .profile-emoji {
      font-size: 34px;
      filter: drop-shadow(0 2px 2px rgba(0,0,0,0.6));
    }
    .profile-name {
      font-weight: 700;
      font-size: 15px;
      color: var(--foam);
    }
    .profile-code {
      font-size: 11px;
      color: var(--cream);
      opacity: 0.9;
    }
    #serverList button {
      margin-top: 4px;
      text-align: left;
      font-size: 13px;
      border-radius: 8px;
      background: linear-gradient(135deg, #6b4f3a 0%, #4a3a2f 100%);
      color: var(--foam);
      text-shadow: none;
      border-color: rgba(215,196,163,0.4);
    }
    #serverList button span.host {
      font-weight: 700;
    }
    #serverList button span.code {
      font-size: 11px;
      opacity: 0.9;
    }
    #serverListEmpty {
      font-size: 12px;
      color: var(--cream);
      opacity: 0.8;
    }
    #gameCanvas {
      background: #1b1412;
      border-radius: 10px;
      border: 1px solid var(--border-soft);
      image-rendering: pixelated;
      display: block;
      margin: 0 auto;
    }
    #gameInfo {
      font-size: 12px;
      color: var(--cream);
      margin-top: 6px;
      min-height: 32px;
    }
    #chatLog {
      height: 180px;
      font-size: 12px;
      background: rgba(26,19,19,0.9);
      color: var(--foam);
    }
    #chatInput {
      margin-top: 4px;
    }
    .screen {
      display: none;
      animation: fadeIn 0.25s ease-out;
    }
    .screen.active {
      display: block;
    }
    .centered {
      text-align: center;
    }
    .small-note {
      font-size: 11px;
      color: var(--cream);
      opacity: 0.8;
      margin-top: 4px;
    }
    .btn-secondary {
      background: rgba(26,19,19,0.9);
      border-color: rgba(215,196,163,0.5);
      color: var(--cream);
      text-shadow: none;
    }
    .btn-secondary:hover:not(:disabled) {
      background: rgba(40,30,25,0.95);
    }
    .device-footer {
      margin-top: 12px;
      padding: 6px 10px;
      font-size: 11px;
      color: var(--cream);
      opacity: 0.8;
      text-align: center;
      border-top: 1px solid rgba(215,196,163,0.25);
    }
    .coffee-dropdown {
      position: relative;
      width: 100%;
      user-select: none;
    }
    .coffee-dropdown-selected {
      background: rgba(26,19,19,0.9);
      border: 1px solid var(--border-soft);
      padding: 10px 14px;
      border-radius: 10px;
      cursor: pointer;
      color: var(--foam);
      font-size: 14px;
    }
    .coffee-dropdown-list {
      display: none;
      position: absolute;
      top: 46px;
      left: 0;
      width: 100%;
      background: rgba(59,47,47,0.98);
      border: 1px solid var(--border-soft);
      border-radius: 10px;
      box-shadow: 0 6px 20px rgba(0,0,0,0.4);
      z-index: 20;
    }
    .coffee-dropdown-list div {
      padding: 10px 14px;
      cursor: pointer;
      color: var(--foam);
      border-bottom: 1px solid rgba(215,196,163,0.15);
    }
    .coffee-dropdown-list div:last-child {
      border-bottom: none;
    }
    .coffee-dropdown-list div:hover {
      background: rgba(215,196,163,0.15);
    }
    .user-card-floating {
      position: fixed;
      right: 12px;
      bottom: 32px;
      z-index: 50;
      background: rgba(26,19,19,0.95);
      border-radius: 12px;
      border: 1px solid var(--border-soft);
      padding: 8px 10px;
      display: flex;
      align-items: center;
      gap: 8px;
      max-width: 220px;
      box-shadow: 0 8px 24px rgba(0,0,0,0.5);
    }
    .user-card-floating .profile-emoji {
      font-size: 26px;
    }
    .user-card-floating .profile-name {
      font-size: 13px;
    }
    .user-card-floating .profile-code {
      font-size: 10px;
    }
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(4px); }
      to { opacity: 1; transform: translateY(0); }
    }
    @media (max-width: 800px) {
      .user-card-floating {
        right: 8px;
        bottom: 60px;
        max-width: 180px;
      }
    }
  </style>
</head>
<body>
  <h1>COFFEE GAME</h1>
  <div class="subtitle">Multiplayer coffee lobby with many little games</div>
  <div class="container">
    <div class="card">
      <!-- SCREEN: BOOT -->
      <div id="screenBoot" class="screen active">
        <div class="row">
          <div class="col">
            <div class="section-title">Player name</div>
            <input id="nameInput" maxlength="20" placeholder="Name (letters, numbers, spaces)" />
          </div>
          <div class="col">
            <div class="section-title">Emoji PFP</div>
            <input id="emojiInput" maxlength="4" placeholder="" />
          </div>
        </div>
        <div class="row">
          <div class="col">
            <button id="makeCoffeeBtn">Make Coffee (Host)</button>
          </div>
          <div class="col">
            <button id="getCoffeeBtn" class="btn-secondary">Get Coffee (Join)</button>
          </div>
        </div>
        <div class="small-note centered">
          Your device codename and OS version will be shared with the room.<br />
          It’s part of Coffee Game canon.
        </div>
        <div id="deviceFooterBoot" class="device-footer"></div>
      </div>

      <!-- SCREEN: HOSTING -->
      <div id="screenHosting" class="screen">
        <div class="row">
          <div class="col">
            <div class="section-title">Host</div>
            <div class="panel">
              <div id="profileCardHost">
                <div id="profileEmojiHost" class="profile-emoji"></div>
                <div>
                  <div id="profileNameHost" class="profile-name">Host</div>
                  <div id="profileCodenameHost" class="profile-code">Codename: Unknown</div>
                  <div id="profileOSHost" class="profile-code">OS: Unknown</div>
                </div>
              </div>
            </div>
          </div>
          <div class="col">
            <div class="section-title">Game selection</div>
            <div class="panel">
              <div class="coffee-dropdown" id="gameDropdown">
                <div class="coffee-dropdown-selected" id="gameDropdownSelected">
                  Select a game…
                </div>
                <div class="coffee-dropdown-list" id="gameDropdownList">
                  <div data-game="snake">Snake (Starvation)</div>
                  <div data-game="pacman">PacMan Duel</div>
                  <div data-game="connect4">Connect 4</div>
                  <div data-game="tictactoe">Tic Tac Toe</div>
                  <div data-game="maze">Mocha Maze Escape</div>
                  <div data-game="tetris">Espresso Tetris</div>
                  <div data-game="chess">Coffee Chess (OP)</div>
                </div>
              </div>
              <div class="small-note" id="hostStatusText">
                Waiting for a player to Get Coffee…
              </div>
            </div>
          </div>
          <div class="col">
            <div class="section-title">Joiner</div>
            <div class="panel">
              <div id="profileCardJoin">
                <div id="profileEmojiJoin" class="profile-emoji"></div>
                <div>
                  <div id="profileNameJoin" class="profile-name">Joiner</div>
                  <div id="profileCodenameJoin" class="profile-code">Codename: Unknown</div>
                  <div id="profileOSJoin" class="profile-code">OS: Unknown</div>
                </div>
              </div>
              <div class="small-note" id="joinerStatusText">Waiting for someone to join…</div>
            </div>
          </div>
        </div>
        <div class="row">
          <div class="col">
            <div class="section-title">Controls</div>
            <div class="panel">
              <div class="small-note">
                Snake: Arrow keys<br />
                PacMan Duel: Player 1 – Arrow keys, Player 2 – WASD<br />
                Connect 4 / Tic Tac Toe: Click columns/tiles<br />
                Tetris: Arrow keys + Space<br />
                Chess: Click piece then destination<br />
                Maze: Arrow keys
              </div>
            </div>
          </div>
        </div>
        <div class="row centered">
          <div class="col">
            <button id="hostBackBtn" class="btn-secondary">Back to Coffee Counter</button>
          </div>
        </div>
        <div id="deviceFooterHosting" class="device-footer"></div>
      </div>

      <!-- SCREEN: SERVER LIST (JOINER) -->
      <div id="screenServerList" class="screen">
        <div class="row">
          <div class="col">
            <div class="section-title">You</div>
            <div class="panel">
              <div id="joinSelfCard">
                <div class="profile-emoji" id="joinSelfEmoji"></div>
                <div>
                  <div class="profile-name" id="joinSelfName">You</div>
                  <div class="profile-code" id="joinSelfCode">Codename: Unknown</div>
                  <div class="profile-code" id="joinSelfOS">OS: Unknown</div>
                </div>
              </div>
            </div>
          </div>
          <div class="col">
            <div class="section-title">
              Available coffee hosts
              <button id="refreshRoomsBtn" class="btn-secondary" style="float:right;max-width:120px;">Refresh</button>
            </div>
            <div class="panel" id="serverList">
              <div id="serverListEmpty">No servers yet. Ask a friend to Make Coffee.</div>
            </div>
          </div>
        </div>
        <div class="row centered">
          <div class="col">
            <button id="joinBackBtn" class="btn-secondary">Back to Coffee Counter</button>
          </div>
        </div>
        <div id="deviceFooterServerList" class="device-footer"></div>
      </div>

      <!-- SCREEN: JOINER LOBBY -->
      <div id="screenJoinLobby" class="screen">
        <div class="row">
          <div class="col">
            <div class="section-title">Host</div>
            <div class="panel">
              <div id="joinLobbyHost">
                <div>Host: <span id="joinLobbyHostName">Unknown</span></div>
                <div class="small-note">Codename: <span id="joinLobbyHostCode">Unknown</span></div>
              </div>
            </div>
          </div>
          <div class="col">
            <div class="section-title">You</div>
            <div class="panel">
              <div id="joinLobbyYou">
                <div>You: <span id="joinLobbyYouName">Unknown</span></div>
                <div class="small-note">Codename: <span id="joinLobbyYouCode">Unknown</span></div>
              </div>
            </div>
          </div>
        </div>
        <div class="row">
          <div class="col">
            <div class="section-title">Status</div>
            <div class="panel">
              <div id="joinLobbyStatus">Waiting for host to pick a game…</div>
            </div>
          </div>
          <div class="col">
            <div class="section-title">Controls</div>
            <div class="panel">
              <div class="small-note">
                Controls depend on the game the host chooses.
              </div>
            </div>
          </div>
        </div>
        <div class="row centered">
          <div class="col">
            <button id="joinLobbyBackBtn" class="btn-secondary">Leave Host</button>
          </div>
        </div>
        <div id="deviceFooterJoinLobby" class="device-footer"></div>
      </div>

      <!-- SCREEN: GAME -->
      <div id="screenGame" class="screen">
        <div class="row">
          <div class="col">
            <div class="section-title">Game</div>
            <div class="panel">
              <canvas id="gameCanvas" width="448" height="448"></canvas>
              <div id="gameInfo"></div>
            </div>
          </div>
          <div class="col">
            <div class="section-title">Chat</div>
            <textarea id="chatLog" readonly></textarea>
            <input id="chatInput" placeholder="Type message and press Enter" />
            <div class="small-note">
              Messages include your codename and OS so everyone knows who’s brewing from where.
            </div>
          </div>
        </div>
        <div class="row centered">
          <div class="col">
            <button id="gameBackBtn" class="btn-secondary">Leave Game</button>
          </div>
        </div>
        <div id="deviceFooterGame" class="device-footer"></div>
      </div>
    </div>
  </div>

  <!-- Floating user card (bottom-right, all screens) -->
  <div class="user-card-floating" id="userFloatingCard">
    <div class="profile-emoji" id="userFloatingEmoji"></div>
    <div>
      <div class="profile-name" id="userFloatingName">Player</div>
      <div class="profile-code" id="userFloatingCode">Codename: Unknown</div>
      <div class="profile-code" id="userFloatingOS">OS: Unknown</div>
    </div>
  </div>

  <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
  <script>
    function detectCodename() {
      const ua = navigator.userAgent || "";
      const lower = ua.toLowerCase();

      if (lower.includes("android")) {
        const match = ua.match(/Android\\s+([0-9]+(?:\\.[0-9]+)?)/i);
        const version = match ? parseFloat(match[1]) : 0;
        if (version >= 9 && version < 10) return "Android Pie";
        if (version >= 10 && version < 11) return "Quince Tart";
        if (version >= 11 && version < 12) return "Red Velvet Cake";
        if (version >= 12 && version < 13) return "Snowcone";
        if (version >= 13 && version < 14) return "Tiramisu";
        if (version >= 14 && version < 15) return "Upside-down Cake";
        if (version >= 15 && version < 16) return "Vanilla Ice Cream";
        if (version >= 16 && version < 17) return "W— uhh, ask Google";
        return "Android";
      }

      if (/iPhone|iPad|iPod/i.test(ua)) {
        const m = ua.match(/OS\\s([0-9_]+)/i);
        const major = m ? parseInt(m[1].split("_")[0], 10) : 0;
        if (major === 14) return "iOS Azul";
        if (major === 15) return "iOS Sky";
        if (major === 16) return "iOS Sydney";
        if (major === 17) return "iOS Dawn";
        if (major === 18) return "iOS Crystal";
        return "iOS";
      }

      if (lower.includes("windows nt 10.0")) return "Windows Threshold";
      if (lower.includes("windows nt 6.3")) return "Windows Blue";
      if (lower.includes("windows nt 6.1")) return "Windows Blackcomb";
      if (lower.includes("windows")) return "Windows";

      if (lower.includes("mac os x")) {
        if (lower.includes("10_15")) return "macOS Catalina";
        if (lower.includes("10_14")) return "macOS Mojave";
        if (lower.includes("10_13")) return "macOS High Sierra";
        if (lower.includes("10_12")) return "macOS Sierra";
        if (lower.includes("10_11")) return "macOS El Capitan";
        if (lower.includes("10_10")) return "macOS Yosemite";
        if (lower.includes("10_9")) return "macOS Mavericks";
        return "macOS";
      }

      if (lower.includes("cros")) return "ChromeOS";
      if (lower.includes("linux")) return "Linux";
      return "Unknown";
    }

    function getOSVersion() {
      const ua = navigator.userAgent || "";
      const android = ua.match(/Android\\s+([0-9]+(?:\\.[0-9]+)?)/i);
      const ios = ua.match(/OS\\s([0-9_]+)/i);
      const win = ua.match(/Windows NT\\s([0-9.]+)/i);
      const mac = ua.match(/Mac OS X\\s([0-9_]+)/i);

      if (android) return "Android " + android[1];
      if (ios) return "iOS " + ios[1].replace(/_/g, ".");
      if (win) return "Windows " + win[1];
      if (mac) return "macOS " + mac[1].replace(/_/g, ".");
      return "Unknown OS";
    }

    function isValidName(name) {
      if (!name) return false;
      if (name.length > 20) return false;
      return /^[A-Za-z0-9 ]+$/.test(name.trim());
    }

    function isSingleEmoji(str) {
      if (!str) return false;
      const t = str.trim();
      if (!t || t.length > 4) return false;
      return !/[A-Za-z0-9]/.test(t);
    }

    const screenBoot = document.getElementById("screenBoot");
    const screenHosting = document.getElementById("screenHosting");
    const screenServerList = document.getElementById("screenServerList");
    const screenJoinLobby = document.getElementById("screenJoinLobby");
    const screenGame = document.getElementById("screenGame");

    const nameInput = document.getElementById("nameInput");
    const emojiInput = document.getElementById("emojiInput");
    const makeCoffeeBtn = document.getElementById("makeCoffeeBtn");
    const getCoffeeBtn = document.getElementById("getCoffeeBtn");

    const profileEmojiHost = document.getElementById("profileEmojiHost");
    const profileNameHost = document.getElementById("profileNameHost");
    const profileCodenameHost = document.getElementById("profileCodenameHost");
    const profileOSHost = document.getElementById("profileOSHost");

    const profileEmojiJoin = document.getElementById("profileEmojiJoin");
    const profileNameJoin = document.getElementById("profileNameJoin");
    const profileCodenameJoin = document.getElementById("profileCodenameJoin");
    const profileOSJoin = document.getElementById("profileOSJoin");
    const joinerStatusText = document.getElementById("joinerStatusText");

    const hostStatusText = document.getElementById("hostStatusText");

    const serverList = document.getElementById("serverList");
    const serverListEmpty = document.getElementById("serverListEmpty");
    const refreshRoomsBtn = document.getElementById("refreshRoomsBtn");

    const joinSelfEmoji = document.getElementById("joinSelfEmoji");
    const joinSelfName = document.getElementById("joinSelfName");
    const joinSelfCode = document.getElementById("joinSelfCode");
    const joinSelfOS = document.getElementById("joinSelfOS");

    const joinLobbyHostName = document.getElementById("joinLobbyHostName");
    const joinLobbyHostCode = document.getElementById("joinLobbyHostCode");
    const joinLobbyYouName = document.getElementById("joinLobbyYouName");
    const joinLobbyYouCode = document.getElementById("joinLobbyYouCode");
    const joinLobbyStatus = document.getElementById("joinLobbyStatus");

    const hostBackBtn = document.getElementById("hostBackBtn");
    const joinBackBtn = document.getElementById("joinBackBtn");
    const joinLobbyBackBtn = document.getElementById("joinLobbyBackBtn");
    const gameBackBtn = document.getElementById("gameBackBtn");

    const gameCanvas = document.getElementById("gameCanvas");
    const gameInfo = document.getElementById("gameInfo");
    const chatLog = document.getElementById("chatLog");
    const chatInput = document.getElementById("chatInput");

    const deviceFooterBoot = document.getElementById("deviceFooterBoot");
    const deviceFooterHosting = document.getElementById("deviceFooterHosting");
    const deviceFooterServerList = document.getElementById("deviceFooterServerList");
    const deviceFooterJoinLobby = document.getElementById("deviceFooterJoinLobby");
    const deviceFooterGame = document.getElementById("deviceFooterGame");

    const userFloatingCard = document.getElementById("userFloatingCard");
    const userFloatingEmoji = document.getElementById("userFloatingEmoji");
    const userFloatingName = document.getElementById("userFloatingName");
    const userFloatingCode = document.getElementById("userFloatingCode");
    const userFloatingOS = document.getElementById("userFloatingOS");

    const gameDropdown = document.getElementById("gameDropdown");
    const gameDropdownSelected = document.getElementById("gameDropdownSelected");
    const gameDropdownList = document.getElementById("gameDropdownList");

    const ctx = gameCanvas.getContext("2d");
    const deviceCodename = detectCodename();
    const deviceOSVersion = getOSVersion();

    function showScreen(el) {
      [screenBoot, screenHosting, screenServerList, screenJoinLobby, screenGame].forEach(s => {
        s.classList.remove("active");
      });
      el.classList.add("active");
      updateAllFooters();
    }

    function updateButtons() {
      const ok = isValidName(nameInput.value) && isSingleEmoji(emojiInput.value);
      makeCoffeeBtn.disabled = !ok;
      getCoffeeBtn.disabled = !ok;
    }

    function currentName() {
      return isValidName(nameInput.value) ? nameInput.value.trim() : "Player";
    }

    function currentEmoji() {
      return emojiInput.value.trim() || "";
    }

    function updateProfiles() {
      const name = currentName();
      const emoji = currentEmoji();

      profileEmojiHost.textContent = emoji;
      profileNameHost.textContent = name;
      profileCodenameHost.textContent = "Codename: " + deviceCodename;
      profileOSHost.textContent = "OS: " + deviceOSVersion;

      profileEmojiJoin.textContent = emoji;
      profileNameJoin.textContent = "Joiner";
      profileCodenameJoin.textContent = "Codename: Unknown";
      profileOSJoin.textContent = "OS: Unknown";

      joinSelfEmoji.textContent = emoji;
      joinSelfName.textContent = name;
      joinSelfCode.textContent = "Codename: " + deviceCodename;
      joinSelfOS.textContent = "OS: " + deviceOSVersion;

      joinLobbyYouName.textContent = name;
      joinLobbyYouCode.textContent = deviceCodename;

      userFloatingEmoji.textContent = emoji;
      userFloatingName.textContent = name;
      userFloatingCode.textContent = "Codename: " + deviceCodename;
      userFloatingOS.textContent = "OS: " + deviceOSVersion;
    }

    function footerText() {
      return deviceCodename + " · " + deviceOSVersion;
    }

    function updateAllFooters() {
      const text = footerText();
      deviceFooterBoot.textContent = text;
      deviceFooterHosting.textContent = text;
      deviceFooterServerList.textContent = text;
      deviceFooterJoinLobby.textContent = text;
      deviceFooterGame.textContent = text;
    }

    nameInput.addEventListener("input", () => {
      updateButtons();
      updateProfiles();
    });
    emojiInput.addEventListener("input", () => {
      updateButtons();
      updateProfiles();
    });

    updateButtons();
    updateProfiles();
    updateAllFooters();

    let selectedGame = null;
    let isHost = false;
    let currentRoomId = null;
    let autoRefreshInterval = null;

    gameDropdownSelected.addEventListener("click", () => {
      gameDropdownList.style.display =
        gameDropdownList.style.display === "block" ? "none" : "block";
    });

    gameDropdownList.querySelectorAll("div").forEach(item => {
      item.addEventListener("click", () => {
        const gameId = item.getAttribute("data-game");
        selectedGame = gameId;
        gameDropdownSelected.textContent = item.textContent;
        gameDropdownList.style.display = "none";

        if (isHost && currentRoomId) {
          socket.emit("select-game", { roomId: currentRoomId, gameId });
          loadGame(gameId);
          showScreen(screenGame);
        }
      });
    });

    document.addEventListener("click", e => {
      if (!gameDropdown.contains(e.target)) {
        gameDropdownList.style.display = "none";
      }
    });

    const socket = io("https://c3l3st1n3k1w1.onrender.com");

    function renderServerList(rooms) {
      serverList.innerHTML = "";
      if (!rooms || rooms.length === 0) {
        serverList.appendChild(serverListEmpty);
        serverListEmpty.style.display = "block";
        return;
      }
      serverListEmpty.style.display = "none";
      rooms.forEach(room => {
        const btn = document.createElement("button");
        const codename = room.platform || "Unknown";
        btn.innerHTML = `
          <span class="host">${room.name}</span>
          <span class="code"> · ${codename}</span>
        `;
        btn.onclick = () => joinRoom(room.id, room);
        serverList.appendChild(btn);
      });
    }

    socket.on("rooms", rooms => {
      renderServerList(rooms);
    });

    socket.on("room-created", room => {
      currentRoomId = room.id;
      isHost = true;
      hostStatusText.textContent = "Waiting for a player to Get Coffee…";
      joinerStatusText.textContent = "Waiting for someone to join…";
      showScreen(screenHosting);
    });

    socket.on("joined-room", room => {
      currentRoomId = room.id;
      isHost = false;
      joinLobbyHostName.textContent = room.name || "Host";
      joinLobbyHostCode.textContent = room.platform || "Unknown";
      joinLobbyStatus.textContent = "Waiting for host to pick a game…";
      showScreen(screenJoinLobby);
    });

    socket.on("chat", msg => {
      chatLog.value += msg + "\\n";
      chatLog.scrollTop = chatLog.scrollHeight;
    });

    socket.on("game-selected", gameId => {
      selectedGame = gameId;
      loadGame(gameId);
      showScreen(screenGame);
    });

    function makeRoom() {
      if (!isValidName(nameInput.value) || !isSingleEmoji(emojiInput.value)) return;
      updateProfiles();
      socket.emit("host-room", {
        name: currentName(),
        emoji: currentEmoji(),
        platform: deviceCodename
      });
      showScreen(screenHosting);
    }

    function requestRooms() {
      socket.emit("list-rooms");
    }

    function joinRoom(roomId, roomMeta) {
      socket.emit("join-room", {
        roomId,
        name: currentName(),
        emoji: currentEmoji(),
        platform: deviceCodename
      });
      if (roomMeta) {
        joinLobbyHostName.textContent = roomMeta.name || "Host";
        joinLobbyHostCode.textContent = roomMeta.platform || "Unknown";
      }
    }

    makeCoffeeBtn.addEventListener("click", () => {
      isHost = true;
      makeRoom();
    });

    getCoffeeBtn.addEventListener("click", () => {
      isHost = false;
      updateProfiles();
      showScreen(screenServerList);
      requestRooms();
      if (autoRefreshInterval) clearInterval(autoRefreshInterval);
      autoRefreshInterval = setInterval(requestRooms, 4000);
    });

    refreshRoomsBtn.addEventListener("click", () => {
      requestRooms();
    });

    hostBackBtn.addEventListener("click", () => {
      if (currentRoomId) socket.emit("leave-room", { roomId: currentRoomId });
      currentRoomId = null;
      isHost = false;
      showScreen(screenBoot);
    });

    joinBackBtn.addEventListener("click", () => {
      if (autoRefreshInterval) clearInterval(autoRefreshInterval);
      showScreen(screenBoot);
    });

    joinLobbyBackBtn.addEventListener("click", () => {
      if (currentRoomId) socket.emit("leave-room", { roomId: currentRoomId });
      currentRoomId = null;
      if (autoRefreshInterval) clearInterval(autoRefreshInterval);
      showScreen(screenServerList);
      requestRooms();
    });

    gameBackBtn.addEventListener("click", () => {
      if (currentRoomId) socket.emit("leave-room", { roomId: currentRoomId });
      currentRoomId = null;
      if (isHost) {
        showScreen(screenHosting);
      } else {
        showScreen(screenServerList);
        requestRooms();
      }
    });

    chatInput.addEventListener("keydown", e => {
      if (e.key === "Enter") {
        e.preventDefault();
        const text = chatInput.value.trim();
        if (!text || !currentRoomId) return;
        socket.emit("chat", {
          roomId: currentRoomId,
          text,
          from: currentName(),
          codename: deviceCodename,
          os: deviceOSVersion
        });
        chatInput.value = "";
      }
    });

    const GRID_SIZE = 28;
    const TILE = 16;
    let snakeActive = false;
    let snakeDir = { x: 1, y: 0 };
    let snakeBody = [];
    let snakeApples = [];
    let snakeStarveCounter = 0;
    let snakeAlive = true;

    function resetSnake() {
      snakeActive = true;
      snakeDir = { x: 1, y: 0 };
      snakeBody = [
        { x: 5, y: 14 },
        { x: 4, y: 14 },
        { x: 3, y: 14 }
      ];
      snakeApples = [];
      for (let i = 0; i < 12; i++) spawnApple();
      snakeStarveCounter = 0;
      snakeAlive = true;
      gameInfo.textContent =
        "Snake (Starvation): Move constantly. Each step without eating increases starvation; too much and you lose segments.";
    }

    function spawnApple() {
      let x, y, bad;
      do {
        x = Math.floor(Math.random() * GRID_SIZE);
        y = Math.floor(Math.random() * GRID_SIZE);
        bad = snakeBody.some(s => s.x === x && s.y === y) ||
              snakeApples.some(a => a.x === x && a.y === y);
      } while (bad);
      snakeApples.push({ x, y });
    }

    function updateSnake() {
      if (!snakeActive || !snakeAlive) return;
      const head = snakeBody[0];
      const nx = head.x + snakeDir.x;
      const ny = head.y + snakeDir.y;

      if (nx < 0 || ny < 0 || nx >= GRID_SIZE || ny >= GRID_SIZE) {
        snakeAlive = false;
        gameInfo.textContent = "Snake: You hit a wall. Starved snake dies.";
        return;
      }

      if (snakeBody.some(s => s.x === nx && s.y === ny)) {
        snakeAlive = false;
        gameInfo.textContent = "Snake: You bit yourself. Game over.";
        return;
      }

      const newHead = { x: nx, y: ny };
      snakeBody.unshift(newHead);

      const appleIndex = snakeApples.findIndex(a => a.x === nx && a.y === ny);
      if (appleIndex >= 0) {
        snakeApples.splice(appleIndex, 1);
        spawnApple();
        snakeStarveCounter = 0;
      } else {
        snakeStarveCounter++;
        if (snakeStarveCounter >= 10) {
          snakeBody.pop();
          snakeStarveCounter = 0;
          if (snakeBody.length <= 2) {
            snakeAlive = false;
            gameInfo.textContent = "Snake: You starved away to nothing.";
            return;
          }
        } else {
          snakeBody.pop();
        }
      }
    }

    function drawSnake() {
      ctx.fillStyle = "#1b1412";
      ctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);

      ctx.fillStyle = "#f2b36f";
      snakeApples.forEach(a => {
        ctx.beginPath();
        ctx.arc(
          a.x * TILE + TILE / 2,
          a.y * TILE + TILE / 2,
          TILE / 2 - 2,
          0,
          Math.PI * 2
        );
        ctx.fill();
      });

      snakeBody.forEach((s, i) => {
        ctx.fillStyle = i === 0 ? "#9be15d" : "#6bbf3a";
        ctx.fillRect(s.x * TILE + 1, s.y * TILE + 1, TILE - 2, TILE - 2);
      });
    }

    const PM_GRID = 28;
    const PM_TILE = 16;

    let pacActive = false;
    let pacPlayers = [];
    let pacGhosts = [];
    let pacPellets = [];
    let pacTick = 0;

    function resetPacman() {
      pacActive = true;
      pacTick = 0;
      pacPlayers = [
        {
          id: 0,
          x: 13,
          y: 20,
          dir: { x: 0, y: -1 },
          hearts: 10,
          color: "#ffeb3b",
          input: { up: false, down: false, left: false, right: false }
        },
        {
          id: 1,
          x: 14,
          y: 20,
          dir: { x: 0, y: -1 },
          hearts: 10,
          color: "#80deea",
          input: { up: false, down: false, left: false, right: false }
        }
      ];
      pacGhosts = [];
      for (let i = 0; i < 16; i++) {
        pacGhosts.push({
          x: 10 + (i % 4),
          y: 10 + Math.floor(i / 4),
          dir: { x: 0, y: 1 },
          color: ["#ff5252", "#f48fb1", "#69f0ae", "#ffb74d"][i % 4]
        });
      }
      pacPellets = [];
      for (let y = 2; y < PM_GRID - 2; y++) {
        for (let x = 2; x < PM_GRID - 2; x++) {
          if ((x + y) % 2 === 0) pacPellets.push({ x, y, eaten: false });
        }
      }
      gameInfo.textContent =
        "Pac-Man Duel: 2 Pac-Men, 16 ghosts, 10 hearts each. Directional bites; knockback when facing each other.";
    }

    function handlePacInput() {
      pacPlayers.forEach(p => {
        if (p.input.up) p.dir = { x: 0, y: -1 };
        else if (p.input.down) p.dir = { x: 0, y: 1 };
        else if (p.input.left) p.dir = { x: -1, y: 0 };
        else if (p.input.right) p.dir = { x: 1, y: 0 };
      });
    }

    function movePacPlayers() {
      pacPlayers.forEach(p => {
        p.x += p.dir.x;
        p.y += p.dir.y;
        if (p.x < 0) p.x = PM_GRID - 1;
        if (p.x >= PM_GRID) p.x = 0;
        if (p.y < 0) p.y = PM_GRID - 1;
        if (p.y >= PM_GRID) p.y = 0;
      });
    }

    function moveGhosts() {
      pacGhosts.forEach(g => {
        if (Math.random() < 0.2) {
          const dirs = [
            { x: 1, y: 0 },
            { x: -1, y: 0 },
            { x: 0, y: 1 },
            { x: 0, y: -1 }
          ];
          g.dir = dirs[Math.floor(Math.random() * dirs.length)];
        }
        g.x += g.dir.x;
        g.y += g.dir.y;
        if (g.x < 0) g.x = PM_GRID - 1;
        if (g.x >= PM_GRID) g.x = 0;
        if (g.y < 0) g.y = PM_GRID - 1;
        if (g.y >= PM_GRID) g.y = 0;
      });
    }

    function eatPellets() {
      pacPlayers.forEach(p => {
        pacPellets.forEach(pe => {
          if (!pe.eaten && pe.x === p.x && pe.y === p.y) {
            pe.eaten = true;
          }
        });
      });
    }

    function pacFacing(a, b) {
      const dx = b.x - a.x;
      const dy = b.y - a.y;
      return (dx === a.dir.x && dy === a.dir.y);
    }

    function pacFacingEachOther(a, b) {
      return pacFacing(a, b) && pacFacing(b, a);
    }

    function pacSameTile(a, b) {
      return a.x === b.x && a.y === b.y;
    }

    function resolvePacCombat() {
      const p0 = pacPlayers[0];
      const p1 = pacPlayers[1];

      if (!pacSameTile(p0, p1)) return;

      if (pacFacingEachOther(p0, p1)) {
        knockback(p0, p1, true);
        return;
      }

      const p0FacingP1 = pacFacing(p0, p1);
      const p1FacingP0 = pacFacing(p1, p0);

      if (p0FacingP1 && !p1FacingP0) {
        bite(p0, p1);
      } else if (p1FacingP0 && !p0FacingP1) {
        bite(p1, p0);
      }
    }

    function bite(attacker, defender) {
      defender.hearts = Math.max(0, defender.hearts - 1);
      knockback(defender, attacker, false);
      if (defender.hearts === 0) {
        gameInfo.textContent =
          "Pac-Man Duel: " + (attacker.id === 0 ? "Player 1" : "Player 2") + " wins (hearts depleted).";
        pacActive = false;
      }
    }

    function knockback(target, source, both) {
      const dx = target.x - source.x;
      const dy = target.y - source.y;
      let kx = 0, ky = 0;
      if (Math.abs(dx) > Math.abs(dy)) kx = dx > 0 ? 1 : -1;
      else if (Math.abs(dy) > 0) ky = dy > 0 ? 1 : -1;

      target.x += kx;
      target.y += ky;
      if (target.x < 0) target.x = PM_GRID - 1;
      if (target.x >= PM_GRID) target.x = 0;
      if (target.y < 0) target.y = PM_GRID - 1;
      if (target.y >= PM_GRID) target.y = 0;

      if (both) {
        source.x -= kx;
        source.y -= ky;
        if (source.x < 0) source.x = PM_GRID - 1;
        if (source.x >= PM_GRID) source.x = 0;
        if (source.y < 0) source.y = PM_GRID - 1;
        if (source.y >= PM_GRID) source.y = 0;
      }
    }

    function drawPacman() {
      ctx.fillStyle = "#1b1412";
      ctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);

      ctx.fillStyle = "#3b2f2f";
      for (let y = 0; y < PM_GRID; y++) {
        for (let x = 0; x < PM_GRID; x++) {
          ctx.fillRect(x * PM_TILE, y * PM_TILE, 1, 1);
        }
      }

      ctx.fillStyle = "#f5eee6";
      pacPellets.forEach(pe => {
        if (!pe.eaten) {
          ctx.beginPath();
          ctx.arc(
            pe.x * PM_TILE + PM_TILE / 2,
            pe.y * PM_TILE + PM_TILE / 2,
            2,
            0,
            Math.PI * 2
          );
          ctx.fill();
        }
      });

      pacGhosts.forEach(g => {
        ctx.fillStyle = g.color;
        ctx.fillRect(g.x * PM_TILE + 2, g.y * PM_TILE + 2, PM_TILE - 4, PM_TILE - 4);
      });

      pacPlayers.forEach(p => {
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(
          p.x * PM_TILE + PM_TILE / 2,
          p.y * PM_TILE + PM_TILE / 2,
          PM_TILE / 2 - 1,
          0,
          Math.PI * 2
        );
        ctx.fill();
      });

      ctx.fillStyle = "#f5eee6";
      ctx.font = "10px Nunito";
      ctx.fillText("P1 Hearts: " + pacPlayers[0].hearts, 4, 12);
      ctx.fillText("P2 Hearts: " + pacPlayers[1].hearts, 4, 24);
    }

    function updatePacman() {
      if (!pacActive) return;
      pacTick++;
      if (pacTick % 4 === 0) {
        handlePacInput();
        movePacPlayers();
        eatPellets();
        moveGhosts();
        resolvePacCombat();
      }
    }

    const C4_COLS = 7;
    const C4_ROWS = 6;
    let c4Board = [];
    let c4Current = 1;
    let c4Active = false;

    function resetConnect4() {
      c4Board = [];
      for (let r = 0; r < C4_ROWS; r++) {
        const row = [];
        for (let c = 0; c < C4_COLS; c++) row.push(0);
        c4Board.push(row);
      }
      c4Current = 1;
      c4Active = true;
      gameInfo.textContent = "Connect 4: Click a column to drop a piece. First to 4 in a row wins.";
    }

    function c4Drop(col) {
      if (!c4Active) return;
      for (let r = C4_ROWS - 1; r >= 0; r--) {
        if (c4Board[r][col] === 0) {
          c4Board[r][col] = c4Current;
          if (c4CheckWin(r, col, c4Current)) {
            gameInfo.textContent = "Connect 4: Player " + c4Current + " wins.";
            c4Active = false;
          } else {
            c4Current = c4Current === 1 ? 2 : 1;
          }
          return;
        }
      }
    }

    function c4CheckWin(r, c, p) {
      const dirs = [
        [1,0],[0,1],[1,1],[1,-1]
      ];
      for (const [dx,dy] of dirs) {
        let count = 1;
        for (let k = 1; k < 4; k++) {
          const nr = r + dy*k, nc = c + dx*k;
          if (nr<0||nr>=C4_ROWS||nc<0||nc>=C4_COLS) break;
          if (c4Board[nr][nc] === p) count++; else break;
        }
        for (let k = 1; k < 4; k++) {
          const nr = r - dy*k, nc = c - dx*k;
          if (nr<0||nr>=C4_ROWS||nc<0||nc>=C4_COLS) break;
          if (c4Board[nr][nc] === p) count++; else break;
        }
        if (count >= 4) return true;
      }
      return false;
    }

    function drawConnect4() {
      ctx.fillStyle = "#2a1f1f";
      ctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);
      const cellW = gameCanvas.width / C4_COLS;
      const cellH = gameCanvas.height / C4_ROWS;
      for (let r = 0; r < C4_ROWS; r++) {
        for (let c = 0; c < C4_COLS; c++) {
          ctx.fillStyle = "#3b2f2f";
          ctx.fillRect(c*cellW+4, r*cellH+4, cellW-8, cellH-8);
          const v = c4Board[r][c];
          if (v !== 0) {
            ctx.beginPath();
            ctx.fillStyle = v === 1 ? "#f2b36f" : "#d7c4a3";
            ctx.arc(
              c*cellW + cellW/2,
              r*cellH + cellH/2,
              Math.min(cellW,cellH)/2 - 6,
              0, Math.PI*2
            );
            ctx.fill();
          }
        }
      }
    }

    let tttBoard = [];
    let tttCurrent = 1;
    let tttActive = false;

    function resetTicTacToe() {
      tttBoard = [];
      for (let r = 0; r < 3; r++) {
        const row = [];
        for (let c = 0; c < 3; c++) row.push(0);
        tttBoard.push(row);
      }
      tttCurrent = 1;
      tttActive = true;
      gameInfo.textContent = "Tic Tac Toe: Click a tile. 3 in a row wins.";
    }

    function tttClick(col, row) {
      if (!tttActive) return;
      if (tttBoard[row][col] !== 0) return;
      tttBoard[row][col] = tttCurrent;
      if (tttCheckWin(tttCurrent)) {
        gameInfo.textContent = "Tic Tac Toe: Player " + tttCurrent + " wins.";
        tttActive = false;
      } else if (tttFull()) {
        gameInfo.textContent = "Tic Tac Toe: Draw.";
        tttActive = false;
      } else {
        tttCurrent = tttCurrent === 1 ? 2 : 1;
      }
    }

    function tttFull() {
      for (let r = 0; r < 3; r++)
        for (let c = 0; c < 3; c++)
          if (tttBoard[r][c] === 0) return false;
      return true;
    }

    function tttCheckWin(p) {
      for (let r = 0; r < 3; r++) {
        if (tttBoard[r][0]===p && tttBoard[r][1]===p && tttBoard[r][2]===p) return true;
      }
      for (let c = 0; c < 3; c++) {
        if (tttBoard[0][c]===p && tttBoard[1][c]===p && tttBoard[2][c]===p) return true;
      }
      if (tttBoard[0][0]===p && tttBoard[1][1]===p && tttBoard[2][2]===p) return true;
      if (tttBoard[0][2]===p && tttBoard[1][1]===p && tttBoard[2][0]===p) return true;
      return false;
    }

    function drawTicTacToe() {
      ctx.fillStyle = "#1b1412";
      ctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);
      const cellW = gameCanvas.width / 3;
      const cellH = gameCanvas.height / 3;
      ctx.strokeStyle = "#d7c4a3";
      ctx.lineWidth = 4;
      for (let i = 1; i < 3; i++) {
        ctx.beginPath();
        ctx.moveTo(i*cellW, 0);
        ctx.lineTo(i*cellW, gameCanvas.height);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(0, i*cellH);
        ctx.lineTo(gameCanvas.width, i*cellH);
        ctx.stroke();
      }
      for (let r = 0; r < 3; r++) {
        for (let c = 0; c < 3; c++) {
          const v = tttBoard[r][c];
          const cx = c*cellW + cellW/2;
          const cy = r*cellH + cellH/2;
          if (v === 1) {
            ctx.strokeStyle = "#f2b36f";
            ctx.beginPath();
            ctx.moveTo(cx-20, cy-20);
            ctx.lineTo(cx+20, cy+20);
            ctx.moveTo(cx+20, cy-20);
            ctx.lineTo(cx-20, cy+20);
            ctx.stroke();
          } else if (v === 2) {
            ctx.strokeStyle = "#d7c4a3";
            ctx.beginPath();
            ctx.arc(cx, cy, 24, 0, Math.PI*2);
            ctx.stroke();
          }
        }
      }
    }

    const MZ_SIZE = 21;
    let mzGrid = [];
    let mzPlayer = { x: 1, y: 1 };
    let mzExit = { x: MZ_SIZE-2, y: MZ_SIZE-2 };
    let mzActive = false;

    function resetMaze() {
      mzGrid = [];
      for (let y = 0; y < MZ_SIZE; y++) {
        const row = [];
        for (let x = 0; x < MZ_SIZE; x++) row.push(1);
        mzGrid.push(row);
      }
      carveMaze(1,1);
      mzPlayer = { x: 1, y: 1 };
      mzExit = { x: MZ_SIZE-2, y: MZ_SIZE-2 };
      mzGrid[mzExit.y][mzExit.x] = 0;
      mzActive = true;
      gameInfo.textContent = "Mocha Maze Escape: Arrow keys to reach the exit.";
    }

    function carveMaze(x,y) {
      mzGrid[y][x] = 0;
      const dirs = [
        [2,0],[-2,0],[0,2],[0,-2]
      ];
      for (let i = dirs.length-1; i>0; i--) {
        const j = Math.floor(Math.random()*(i+1));
        [dirs[i],dirs[j]] = [dirs[j],dirs[i]];
      }
      for (const [dx,dy] of dirs) {
        const nx = x+dx, ny = y+dy;
        if (nx>0 && nx<MZ_SIZE-1 && ny>0 && ny<MZ_SIZE-1 && mzGrid[ny][nx]===1) {
          mzGrid[y+dy/2][x+dx/2] = 0;
          carveMaze(nx,ny);
        }
      }
    }

    function moveMaze(dx,dy) {
      if (!mzActive) return;
      const nx = mzPlayer.x + dx;
      const ny = mzPlayer.y + dy;
      if (nx<0||ny<0||nx>=MZ_SIZE||ny>=MZ_SIZE) return;
      if (mzGrid[ny][nx] === 1) return;
      mzPlayer.x = nx;
      mzPlayer.y = ny;
      if (nx === mzExit.x && ny === mzExit.y) {
        mzActive = false;
        gameInfo.textContent = "Mocha Maze Escape: You reached the exit.";
      }
    }

    function drawMaze() {
      ctx.fillStyle = "#1b1412";
      ctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);
      const cell = gameCanvas.width / MZ_SIZE;
      for (let y = 0; y < MZ_SIZE; y++) {
        for (let x = 0; x < MZ_SIZE; x++) {
          if (mzGrid[y][x] === 1) {
            ctx.fillStyle = "#3b2f2f";
          } else {
            ctx.fillStyle = "#2a1f1f";
          }
          ctx.fillRect(x*cell, y*cell, cell, cell);
        }
      }
      ctx.fillStyle = "#f2b36f";
      ctx.fillRect(mzExit.x*cell+4, mzExit.y*cell+4, cell-8, cell-8);
      ctx.fillStyle = "#d7c4a3";
      ctx.beginPath();
      ctx.arc(
        mzPlayer.x*cell + cell/2,
        mzPlayer.y*cell + cell/2,
        cell/2 - 4,
        0, Math.PI*2
      );
      ctx.fill();
    }

    const T_COLS = 10;
    const T_ROWS = 20;
    const T_SIZE = 20;
    let tGrid = [];
    let tPiece = null;
    let tX = 0, tY = 0;
    let tActive = false;
    let tTick = 0;

    const T_SHAPES = [
      [[1,1,1,1]],
      [[1,1],[1,1]],
      [[0,1,0],[1,1,1]],
      [[1,0,0],[1,1,1]],
      [[0,0,1],[1,1,1]],
      [[1,1,0],[0,1,1]],
      [[0,1,1],[1,1,0]]
    ];

    function resetTetris() {
      tGrid = [];
      for (let r = 0; r < T_ROWS; r++) {
        const row = [];
        for (let c = 0; c < T_COLS; c++) row.push(0);
        tGrid.push(row);
      }
      tActive = true;
      tTick = 0;
      spawnPiece();
      gameInfo.textContent = "Espresso Tetris: Arrow keys to move, Space to drop.";
    }

    function spawnPiece() {
      tPiece = T_SHAPES[Math.floor(Math.random()*T_SHAPES.length)];
      tX = Math.floor(T_COLS/2) - 2;
      tY = 0;
      if (!tValid(tX,tY,tPiece)) {
        tActive = false;
        gameInfo.textContent = "Espresso Tetris: Board filled.";
      }
    }

    function tValid(x,y,shape) {
      for (let r = 0; r < shape.length; r++) {
        for (let c = 0; c < shape[r].length; c++) {
          if (!shape[r][c]) continue;
          const nx = x+c, ny = y+r;
          if (nx<0||nx>=T_COLS||ny>=T_ROWS) return false;
          if (ny>=0 && tGrid[ny][nx]) return false;
        }
      }
      return true;
    }

    function tRotate() {
      const s = tPiece;
      const h = s.length, w = s[0].length;
      const rotated = [];
      for (let c = 0; c < w; c++) {
        const row = [];
        for (let r = h-1; r>=0; r--) {
          row.push(s[r][c]);
        }
        rotated.push(row);
      }
      if (tValid(tX,tY,rotated)) tPiece = rotated;
    }

    function tStep() {
      if (!tActive) return;
      if (tValid(tX,tY+1,tPiece)) {
        tY++;
      } else {
        for (let r = 0; r < tPiece.length; r++) {
          for (let c = 0; c < tPiece[r].length; c++) {
            if (!tPiece[r][c]) continue;
            const nx = tX+c, ny = tY+r;
            if (ny>=0 && ny<T_ROWS && nx>=0 && nx<T_COLS) {
              tGrid[ny][nx] = 1;
            }
          }
        }
        tClearLines();
        spawnPiece();
      }
    }

    function tClearLines() {
      for (let r = T_ROWS-1; r>=0; r--) {
        if (tGrid[r].every(v=>v!==0)) {
          tGrid.splice(r,1);
          const row = [];
          for (let c = 0; c < T_COLS; c++) row.push(0);
          tGrid.unshift(row);
          r++;
        }
      }
    }

    function drawTetris() {
      ctx.fillStyle = "#1b1412";
      ctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);
      const offsetX = (gameCanvas.width - T_COLS*T_SIZE)/2;
      const offsetY = (gameCanvas.height - T_ROWS*T_SIZE)/2;
      for (let r = 0; r < T_ROWS; r++) {
        for (let c = 0; c < T_COLS; c++) {
          if (tGrid[r][c]) {
            ctx.fillStyle = "#f2b36f";
            ctx.fillRect(offsetX+c*T_SIZE, offsetY+r*T_SIZE, T_SIZE-1, T_SIZE-1);
          } else {
            ctx.fillStyle = "#2a1f1f";
            ctx.fillRect(offsetX+c*T_SIZE, offsetY+r*T_SIZE, T_SIZE-1, T_SIZE-1);
          }
        }
      }
      if (tPiece) {
        ctx.fillStyle = "#d7c4a3";
        for (let r = 0; r < tPiece.length; r++) {
          for (let c = 0; c < tPiece[r].length; c++) {
            if (!tPiece[r][c]) continue;
            const nx = tX+c, ny = tY+r;
            ctx.fillRect(offsetX+nx*T_SIZE, offsetY+ny*T_SIZE, T_SIZE-1, T_SIZE-1);
          }
        }
      }
    }

    function updateTetris() {
      if (!tActive) return;
      tTick++;
      if (tTick % 20 === 0) tStep();
    }

    const CH_SIZE = 8;
    let chBoard = [];
    let chSelected = null;
    let chTurn = 1;
    let chActive = false;

    function resetChess() {
      chBoard = [];
      for (let r = 0; r < CH_SIZE; r++) {
        const row = [];
        for (let c = 0; c < CH_SIZE; c++) row.push(null);
        chBoard.push(row);
      }
      for (let c = 0; c < CH_SIZE; c++) {
        chBoard[1][c] = { p: "P", side: 2 };
        chBoard[6][c] = { p: "P", side: 1 };
      }
      chBoard[0][4] = { p: "K", side: 2 };
      chBoard[7][4] = { p: "K", side: 1 };
      chSelected = null;
      chTurn = 1;
      chActive = true;
      gameInfo.textContent = "Coffee Chess (OP lite): Pawns + Kings. Click piece then destination.";
    }

    function chInside(x,y) {
      return x>=0 && x<CH_SIZE && y>=0 && y<CH_SIZE;
    }

    function chMove(fromX,fromY,toX,toY) {
      if (!chActive) return;
      const piece = chBoard[fromY][fromX];
      if (!piece || piece.side !== chTurn) return;
      const target = chBoard[toY][toX];
      const dx = toX-fromX, dy = toY-fromY;
      if (piece.p === "P") {
        const dir = piece.side === 1 ? -1 : 1;
        if (dx === 0 && dy === dir && !target) {
          chBoard[toY][toX] = piece;
          chBoard[fromY][fromX] = null;
        } else if (Math.abs(dx)===1 && dy===dir && target && target.side!==piece.side) {
          chBoard[toY][toX] = piece;
          chBoard[fromY][fromX] = null;
        } else {
          return;
        }
      } else if (piece.p === "K") {
        if (Math.abs(dx)<=1 && Math.abs(dy)<=1) {
          if (!target || target.side!==piece.side) {
            chBoard[toY][toX] = piece;
            chBoard[fromY][fromX] = null;
          } else return;
        } else return;
      }
      if (target && target.p==="K") {
        chActive = false;
        gameInfo.textContent = "Coffee Chess: Side " + piece.side + " captures the king.";
      } else {
        chTurn = chTurn===1?2:1;
      }
    }

    function drawChess() {
      ctx.fillStyle = "#1b1412";
      ctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);
      const cell = gameCanvas.width / CH_SIZE;
      for (let y = 0; y < CH_SIZE; y++) {
        for (let x = 0; x < CH_SIZE; x++) {
          ctx.fillStyle = (x+y)%2===0 ? "#3b2f2f" : "#6b4f3a";
          ctx.fillRect(x*cell, y*cell, cell, cell);
          const piece = chBoard[y][x];
          if (piece) {
            ctx.fillStyle = piece.side===1 ? "#f5eee6" : "#d7c4a3";
            ctx.font = "20px Nunito";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(piece.p, x*cell+cell/2, y*cell+cell/2);
          }
        }
      }
      if (chSelected) {
        ctx.strokeStyle = "#f2b36f";
        ctx.lineWidth = 3;
        ctx.strokeRect(chSelected.x*cell+2, chSelected.y*cell+2, cell-4, cell-4);
      }
    }

    let currentGame = null;

    function loadGame(gameId) {
      currentGame = gameId;
      if (gameId === "snake") {
        resetSnake();
      } else if (gameId === "pacman") {
        resetPacman();
      } else if (gameId === "connect4") {
        resetConnect4();
      } else if (gameId === "tictactoe") {
        resetTicTacToe();
      } else if (gameId === "maze") {
        resetMaze();
      } else if (gameId === "tetris") {
        resetTetris();
      } else if (gameId === "chess") {
        resetChess();
      } else {
        ctx.fillStyle = "#1b1412";
        ctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);
        gameInfo.textContent = "Waiting for game selection…";
      }
    }

    function loop() {
      requestAnimationFrame(loop);
      if (currentGame === "snake") {
        updateSnake();
        drawSnake();
      } else if (currentGame === "pacman") {
        updatePacman();
        drawPacman();
      } else if (currentGame === "connect4") {
        drawConnect4();
      } else if (currentGame === "tictactoe") {
        drawTicTacToe();
      } else if (currentGame === "maze") {
        drawMaze();
      } else if (currentGame === "tetris") {
        updateTetris();
        drawTetris();
      } else if (currentGame === "chess") {
        drawChess();
      }
    }
    loop();

    window.addEventListener("keydown", e => {
      if (currentGame === "snake") {
        if (e.key === "ArrowUp" && snakeDir.y !== 1) snakeDir = { x: 0, y: -1 };
        else if (e.key === "ArrowDown" && snakeDir.y !== -1) snakeDir = { x: 0, y: 1 };
        else if (e.key === "ArrowLeft" && snakeDir.x !== 1) snakeDir = { x: -1, y: 0 };
        else if (e.key === "ArrowRight" && snakeDir.x !== -1) snakeDir = { x: 1, y: 0 };
      } else if (currentGame === "pacman") {
        const p0 = pacPlayers[0];
        const p1 = pacPlayers[1];
        if (!p0 || !p1) return;

        if (e.key === "ArrowUp") { p0.input = { up: true, down: false, left: false, right: false }; }
        else if (e.key === "ArrowDown") { p0.input = { up: false, down: true, left: false, right: false }; }
        else if (e.key === "ArrowLeft") { p0.input = { up: false, down: false, left: true, right: false }; }
        else if (e.key === "ArrowRight") { p0.input = { up: false, down: false, left: false, right: true }; }

        if (e.key === "w") { p1.input = { up: true, down: false, left: false, right: false }; }
        else if (e.key === "s") { p1.input = { up: false, down: true, left: false, right: false }; }
        else if (e.key === "a") { p1.input = { up: false, down: false, left: true, right: false }; }
        else if (e.key === "d") { p1.input = { up: false, down: false, left: false, right: true }; }
      } else if (currentGame === "maze") {
        if (e.key === "ArrowUp") moveMaze(0,-1);
        else if (e.key === "ArrowDown") moveMaze(0,1);
        else if (e.key === "ArrowLeft") moveMaze(-1,0);
        else if (e.key === "ArrowRight") moveMaze(1,0);
      } else if (currentGame === "tetris") {
        if (e.key === "ArrowLeft") {
          if (tValid(tX-1,tY,tPiece)) tX--;
        } else if (e.key === "ArrowRight") {
          if (tValid(tX+1,tY,tPiece)) tX++;
        } else if (e.key === "ArrowDown") {
          if (tValid(tX,tY+1,tPiece)) tY++;
        } else if (e.key === " ") {
          while (tValid(tX,tY+1,tPiece)) tY++;
          tStep();
        } else if (e.key === "ArrowUp") {
          tRotate();
        }
      }
    });

    gameCanvas.addEventListener("click", e => {
      const rect = gameCanvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      if (currentGame === "connect4") {
        const col = Math.floor(x / (gameCanvas.width / C4_COLS));
        if (col>=0 && col<C4_COLS) c4Drop(col);
      } else if (currentGame === "tictactoe") {
        const col = Math.floor(x / (gameCanvas.width / 3));
        const row = Math.floor(y / (gameCanvas.height / 3));
        if (col>=0 && col<3 && row>=0 && row<3) tttClick(col,row);
      } else if (currentGame === "chess") {
        const cell = gameCanvas.width / CH_SIZE;
        const cx = Math.floor(x / cell);
        const cy = Math.floor(y / cell);
        if (!chInside(cx,cy)) return;
        const piece = chBoard[cy][cx];
        if (chSelected) {
          chMove(chSelected.x,chSelected.y,cx,cy);
          chSelected = null;
        } else {
          if (piece && piece.side===chTurn) {
            chSelected = { x: cx, y: cy };
          }
        }
      }
    });
  </script>
</body>
</html>