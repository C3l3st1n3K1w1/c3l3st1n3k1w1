<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Coffee</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      background: #050509;
      color: #f5f5f5;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    h1 {
      margin: 16px 0 8px;
      font-size: 24px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
    }
    .container {
      width: 100%;
      max-width: 1000px;
      padding: 16px;
    }
    .row {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      margin-bottom: 12px;
    }
    .col {
      flex: 1;
      min-width: 260px;
    }
    .section-title {
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: #aaa;
      margin-bottom: 4px;
    }
    input, select, button, textarea {
      width: 100%;
      padding: 8px;
      border-radius: 4px;
      border: 1px solid #333;
      background: #151520;
      color: #f5f5f5;
      font-size: 14px;
    }
    button {
      cursor: pointer;
      border: 1px solid #555;
      background: #24243a;
    }
    button:disabled {
      opacity: 0.4;
      cursor: default;
    }
    .panel {
      border-radius: 6px;
      border: 1px solid #262636;
      background: #11111a;
      padding: 8px;
      min-height: 80px;
    }
    #profileCard {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    #profileEmoji {
      font-size: 32px;
    }
    #profileName {
      font-weight: 600;
    }
    #profileCodename {
      font-size: 12px;
      color: #bbb;
    }
    #serverList button {
      margin-top: 4px;
      text-align: left;
      font-size: 13px;
    }
    #gameCanvas {
      background: #000;
      border-radius: 4px;
      border: 1px solid #333;
      image-rendering: pixelated;
    }
    #gameInfo {
      font-size: 12px;
      color: #ccc;
      margin-top: 4px;
      min-height: 32px;
    }
    #chatLog {
      height: 160px;
      resize: none;
      font-size: 12px;
    }
    #chatInput {
      margin-top: 4px;
    }
    .tag {
      display: inline-block;
      padding: 2px 6px;
      border-radius: 999px;
      border: 1px solid #444;
      font-size: 11px;
      color: #ccc;
      margin-left: 4px;
    }
  </style>
</head>
<body>
  <h1>COFFEE GAME</h1>
  <div class="container">
    <!-- BOOT -->
    <div class="row">
      <div class="col">
        <div class="section-title">Player name</div>
        <input id="nameInput" maxlength="20" placeholder="Name (letters, numbers, spaces)" />
      </div>
      <div class="col">
        <div class="section-title">Emoji PFP</div>
        <input id="emojiInput" maxlength="4" placeholder="" />
      </div>
    </div>

    <div class="row">
      <div class="col">
        <button id="makeCoffeeBtn">Make Coffee (Host)</button>
      </div>
      <div class="col">
        <button id="getCoffeeBtn">Get Coffee (Join)</button>
      </div>
    </div>

    <!-- PROFILE + SERVERS -->
    <div class="row">
      <div class="col">
        <div class="section-title">Your profile</div>
        <div class="panel">
          <div id="profileCard">
            <div id="profileEmoji"></div>
            <div>
              <div id="profileName">Not connected</div>
              <div id="profileCodename">Codename: Unknown</div>
            </div>
          </div>
        </div>
      </div>
      <div class="col">
        <div class="section-title">Servers</div>
        <div class="panel" id="serverList">
          <div id="serverListEmpty">No servers yet.</div>
        </div>
      </div>
    </div>

    <!-- GAME + CHAT -->
    <div class="row">
      <div class="col">
        <div class="section-title">Game selection (host)</div>
        <select id="gameSelect" disabled>
          <option value="">Select a game…</option>
          <option value="snake">Snake (Starvation)</option>
          <option value="pacman">Pac-Man Duel</option>
        </select>
        <div class="section-title" style="margin-top:8px;">Game area</div>
        <div class="panel">
          <canvas id="gameCanvas" width="448" height="448"></canvas>
          <div id="gameInfo"></div>
        </div>
      </div>
      <div class="col">
        <div class="section-title">Chat</div>
        <textarea id="chatLog" readonly></textarea>
        <input id="chatInput" placeholder="Type message and press Enter" />
      </div>
    </div>
  </div>

  <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
  <script>
    // ===== CODENAME RESOLVER (COFFEE GAME CANON) =====
    function detectCodename() {
      const ua = navigator.userAgent || "";
      const lower = ua.toLowerCase();

      if (lower.includes("android")) {
        const m = ua.match(/Android\s+([0-9]+(?:\.[0-9]+)?)/i);
        const v = m ? m[1] : "";
        if (v.startsWith("9")) return "Android Pie";
        if (v.startsWith("10")) return "Android Quince";
        if (v.startsWith("11")) return "Android Red Velvet";
        if (v.startsWith("12")) return "Android Snowcone";
        if (v.startsWith("13")) return "Android Tiramisu";
        if (v.startsWith("14")) return "Android Upside-down Cake";
        if (v.startsWith("15")) return "Android Vanilla";
        if (v.startsWith("16")) return "Android Wisteria";
        return "Android";
      }

      if (/iPhone|iPad|iPod/i.test(ua)) {
        const m = ua.match(/OS\s([0-9]+)_/i);
        const major = m ? parseInt(m[1], 10) : 0;
        if (major === 14) return "iOS Azul";
        if (major === 15) return "iOS Sky";
        if (major === 16) return "iOS Sydney";
        if (major === 17) return "iOS Dawn";
        if (major === 18) return "iOS Crystal";
        return "iOS";
      }

      if (lower.includes("windows nt 10.0")) return "Windows Threshold";
      if (lower.includes("windows nt 6.3")) return "Windows Blue";
      if (lower.includes("windows nt 6.1")) return "Windows Blackcomb";
      if (lower.includes("windows")) return "Windows";

      if (lower.includes("mac os x")) {
        if (lower.includes("10_15")) return "macOS Catalina";
        if (lower.includes("10_14")) return "macOS Mojave";
        if (lower.includes("10_13")) return "macOS High Sierra";
        if (lower.includes("10_12")) return "macOS Sierra";
        if (lower.includes("10_11")) return "macOS El Capitan";
        if (lower.includes("10_10")) return "macOS Yosemite";
        if (lower.includes("10_9")) return "macOS Mavericks";
        return "macOS";
      }

      if (lower.includes("cros")) return "ChromeOS";
      if (lower.includes("linux")) return "Linux";
      return "Unknown";
    }

    // ===== BASIC VALIDATION =====
    function isValidName(name) {
      if (!name) return false;
      if (name.length > 20) return false;
      return /^[A-Za-z0-9 ]+$/.test(name.trim());
    }

    function isSingleEmoji(str) {
      if (!str) return false;
      const t = str.trim();
      if (!t || t.length > 4) return false;
      return !/[A-Za-z0-9]/.test(t);
    }

    // ===== DOM =====
    const nameInput = document.getElementById("nameInput");
    const emojiInput = document.getElementById("emojiInput");
    const makeCoffeeBtn = document.getElementById("makeCoffeeBtn");
    const getCoffeeBtn = document.getElementById("getCoffeeBtn");
    const profileEmoji = document.getElementById("profileEmoji");
    const profileName = document.getElementById("profileName");
    const profileCodename = document.getElementById("profileCodename");
    const serverList = document.getElementById("serverList");
    const serverListEmpty = document.getElementById("serverListEmpty");
    const gameSelect = document.getElementById("gameSelect");
    const gameCanvas = document.getElementById("gameCanvas");
    const gameInfo = document.getElementById("gameInfo");
    const chatLog = document.getElementById("chatLog");
    const chatInput = document.getElementById("chatInput");

    const ctx = gameCanvas.getContext("2d");
    const deviceCodename = detectCodename();

    function updateProfileCard() {
      profileEmoji.textContent = emojiInput.value.trim() || "";
      profileName.textContent = isValidName(nameInput.value) ? nameInput.value.trim() : "Not connected";
      profileCodename.textContent = "Codename: " + deviceCodename;
    }

    function updateButtons() {
      const ok = isValidName(nameInput.value) && isSingleEmoji(emojiInput.value);
      makeCoffeeBtn.disabled = !ok;
      getCoffeeBtn.disabled = !ok;
    }

    nameInput.addEventListener("input", () => {
      updateButtons();
      updateProfileCard();
    });
    emojiInput.addEventListener("input", () => {
      updateButtons();
      updateProfileCard();
    });

    updateButtons();
    updateProfileCard();

    // ===== SOCKET =====
    const socket = io("https://c3l3st1n3k1w1.onrender.com");
    let currentRoomId = null;
    let isHost = false;

    function renderServerList(rooms) {
      serverList.innerHTML = "";
      if (!rooms || rooms.length === 0) {
        serverList.appendChild(serverListEmpty);
        serverListEmpty.style.display = "block";
        return;
      }
      serverListEmpty.style.display = "none";
      rooms.forEach(room => {
        const btn = document.createElement("button");
        const codename = room.platform || "Unknown";
        btn.textContent = `Join: ${room.name} (${codename})`;
        btn.onclick = () => joinRoom(room.id);
        serverList.appendChild(btn);
      });
    }

    socket.on("connect", () => {
      socket.emit("list-rooms");
    });

    socket.on("rooms", rooms => {
      renderServerList(rooms);
    });

    socket.on("room-created", room => {
      currentRoomId = room.id;
      isHost = true;
      gameSelect.disabled = false;
      gameInfo.textContent = "Waiting for a player to Get Coffee…";
    });

    socket.on("joined-room", room => {
      currentRoomId = room.id;
      isHost = false;
      gameSelect.disabled = true;
      gameInfo.textContent = "Connected. Waiting for host to select a game…";
    });

    socket.on("chat", msg => {
      chatLog.value += msg + "\n";
      chatLog.scrollTop = chatLog.scrollHeight;
    });

    socket.on("game-selected", gameId => {
      loadGame(gameId);
    });

    // ===== ACTIONS =====
    function makeRoom() {
      if (!isValidName(nameInput.value) || !isSingleEmoji(emojiInput.value)) return;
      updateProfileCard();
      socket.emit("host-room", {
        name: nameInput.value.trim(),
        emoji: emojiInput.value.trim(),
        platform: deviceCodename
      });
    }

    function getRooms() {
      if (!isValidName(nameInput.value) || !isSingleEmoji(emojiInput.value)) return;
      updateProfileCard();
      socket.emit("list-rooms");
    }

    function joinRoom(roomId) {
      socket.emit("join-room", {
        roomId,
        name: nameInput.value.trim(),
        emoji: emojiInput.value.trim(),
        platform: deviceCodename
      });
    }

    makeCoffeeBtn.addEventListener("click", makeRoom);
    getCoffeeBtn.addEventListener("click", getRooms);

    // ===== GAME SELECT =====
    gameSelect.addEventListener("change", () => {
      if (!isHost || !currentRoomId) return;
      const gameId = gameSelect.value;
      if (!gameId) return;
      socket.emit("select-game", { roomId: currentRoomId, gameId });
      loadGame(gameId);
    });

    // ===== SNAKE (STARVATION MODE) =====
    const GRID_SIZE = 28;
    const TILE = 16;
    let snakeActive = false;
    let snakeDir = { x: 1, y: 0 };
    let snakeBody = [];
    let snakeApples = [];
    let snakeStarveCounter = 0;
    let snakeAlive = true;

    function resetSnake() {
      snakeActive = true;
      snakeDir = { x: 1, y: 0 };
      snakeBody = [
        { x: 5, y: 14 },
        { x: 4, y: 14 },
        { x: 3, y: 14 }
      ];
      snakeApples = [];
      for (let i = 0; i < 12; i++) spawnApple();
      snakeStarveCounter = 0;
      snakeAlive = true;
      gameInfo.textContent =
        "Snake (Starvation): Move constantly. Each step without eating increases starvation; too much and you lose segments.";
    }

    function spawnApple() {
      let x, y, bad;
      do {
        x = Math.floor(Math.random() * GRID_SIZE);
        y = Math.floor(Math.random() * GRID_SIZE);
        bad = snakeBody.some(s => s.x === x && s.y === y) ||
              snakeApples.some(a => a.x === x && a.y === y);
      } while (bad);
      snakeApples.push({ x, y });
    }

    function updateSnake() {
      if (!snakeActive || !snakeAlive) return;
      const head = snakeBody[0];
      const nx = head.x + snakeDir.x;
      const ny = head.y + snakeDir.y;

      if (nx < 0 || ny < 0 || nx >= GRID_SIZE || ny >= GRID_SIZE) {
        snakeAlive = false;
        gameInfo.textContent = "Snake: You hit a wall. Starved snake dies.";
        return;
      }

      if (snakeBody.some(s => s.x === nx && s.y === ny)) {
        snakeAlive = false;
        gameInfo.textContent = "Snake: You bit yourself. Game over.";
        return;
      }

      const newHead = { x: nx, y: ny };
      snakeBody.unshift(newHead);

      const appleIndex = snakeApples.findIndex(a => a.x === nx && a.y === ny);
      if (appleIndex >= 0) {
        snakeApples.splice(appleIndex, 1);
        spawnApple();
        snakeStarveCounter = 0;
      } else {
        snakeStarveCounter++;
        if (snakeStarveCounter >= 10) {
          snakeBody.pop();
          snakeStarveCounter = 0;
          if (snakeBody.length <= 2) {
            snakeAlive = false;
            gameInfo.textContent = "Snake: You starved away to nothing.";
            return;
          }
        } else {
          snakeBody.pop();
        }
      }
    }

    function drawSnake() {
      ctx.fillStyle = "#000";
      ctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);

      ctx.fillStyle = "#f00";
      snakeApples.forEach(a => {
        ctx.fillRect(a.x * TILE, a.y * TILE, TILE, TILE);
      });

      snakeBody.forEach((s, i) => {
        ctx.fillStyle = i === 0 ? "#0f0" : "#0a0";
        ctx.fillRect(s.x * TILE, s.y * TILE, TILE, TILE);
      });
    }

    // ===== PAC-MAN DUEL =====
    const PM_GRID = 28;
    const PM_TILE = 16;

    let pacActive = false;
    let pacPlayers = [];
    let pacGhosts = [];
    let pacPellets = [];
    let pacTick = 0;

    function resetPacman() {
      pacActive = true;
      pacTick = 0;
      pacPlayers = [
        {
          id: 0,
          x: 13,
          y: 20,
          dir: { x: 0, y: -1 },
          hearts: 10,
          color: "#ff0",
          input: { up: false, down: false, left: false, right: false }
        },
        {
          id: 1,
          x: 14,
          y: 20,
          dir: { x: 0, y: -1 },
          hearts: 10,
          color: "#0ff",
          input: { up: false, down: false, left: false, right: false }
        }
      ];
      pacGhosts = [];
      for (let i = 0; i < 16; i++) {
        pacGhosts.push({
          x: 10 + (i % 4),
          y: 10 + Math.floor(i / 4),
          dir: { x: 0, y: 1 },
          color: ["#f00", "#f9c", "#0f0", "#f80"][i % 4]
        });
      }
      pacPellets = [];
      for (let y = 2; y < PM_GRID - 2; y++) {
        for (let x = 2; x < PM_GRID - 2; x++) {
          if ((x + y) % 2 === 0) pacPellets.push({ x, y, eaten: false });
        }
      }
      gameInfo.textContent =
        "Pac-Man Duel: 2 Pac-Men, 16 ghosts, 10 hearts each. Directional bites; knockback when facing each other.";
    }

    function handlePacInput() {
      pacPlayers.forEach(p => {
        if (p.input.up) p.dir = { x: 0, y: -1 };
        else if (p.input.down) p.dir = { x: 0, y: 1 };
        else if (p.input.left) p.dir = { x: -1, y: 0 };
        else if (p.input.right) p.dir = { x: 1, y: 0 };
      });
    }

    function movePacPlayers() {
      pacPlayers.forEach(p => {
        p.x += p.dir.x;
        p.y += p.dir.y;
        if (p.x < 0) p.x = PM_GRID - 1;
        if (p.x >= PM_GRID) p.x = 0;
        if (p.y < 0) p.y = PM_GRID - 1;
        if (p.y >= PM_GRID) p.y = 0;
      });
    }

    function moveGhosts() {
      pacGhosts.forEach(g => {
        if (Math.random() < 0.2) {
          const dirs = [
            { x: 1, y: 0 },
            { x: -1, y: 0 },
            { x: 0, y: 1 },
            { x: 0, y: -1 }
          ];
          g.dir = dirs[Math.floor(Math.random() * dirs.length)];
        }
        g.x += g.dir.x;
        g.y += g.dir.y;
        if (g.x < 0) g.x = PM_GRID - 1;
        if (g.x >= PM_GRID) g.x = 0;
        if (g.y < 0) g.y = PM_GRID - 1;
        if (g.y >= PM_GRID) g.y = 0;
      });
    }

    function eatPellets() {
      pacPlayers.forEach(p => {
        pacPellets.forEach(pe => {
          if (!pe.eaten && pe.x === p.x && pe.y === p.y) {
            pe.eaten = true;
          }
        });
      });
    }

    function pacFacing(a, b) {
      const dx = b.x - a.x;
      const dy = b.y - a.y;
      return (dx === a.dir.x && dy === a.dir.y);
    }

    function pacFacingEachOther(a, b) {
      return pacFacing(a, b) && pacFacing(b, a);
    }

    function pacSameTile(a, b) {
      return a.x === b.x && a.y === b.y;
    }

    function resolvePacCombat() {
      const p0 = pacPlayers[0];
      const p1 = pacPlayers[1];

      if (!pacSameTile(p0, p1)) return;

      if (pacFacingEachOther(p0, p1)) {
        knockback(p0, p1, true);
        return;
      }

      const p0FacingP1 = pacFacing(p0, p1);
      const p1FacingP0 = pacFacing(p1, p0);

      if (p0FacingP1 && !p1FacingP0) {
        bite(p0, p1);
      } else if (p1FacingP0 && !p0FacingP1) {
        bite(p1, p0);
      }
    }

    function bite(attacker, defender) {
      defender.hearts = Math.max(0, defender.hearts - 1);
      knockback(defender, attacker, false);
      if (defender.hearts === 0) {
        gameInfo.textContent =
          "Pac-Man Duel: " + (attacker.id === 0 ? "Player 1" : "Player 2") + " wins (hearts depleted).";
        pacActive = false;
      }
    }

    function knockback(target, source, both) {
      const dx = target.x - source.x;
      const dy = target.y - source.y;
      let kx = 0, ky = 0;
      if (Math.abs(dx) > Math.abs(dy)) kx = dx > 0 ? 1 : -1;
      else if (Math.abs(dy) > 0) ky = dy > 0 ? 1 : -1;

      target.x += kx;
      target.y += ky;
      if (target.x < 0) target.x = PM_GRID - 1;
      if (target.x >= PM_GRID) target.x = 0;
      if (target.y < 0) target.y = PM_GRID - 1;
      if (target.y >= PM_GRID) target.y = 0;

      if (both) {
        source.x -= kx;
        source.y -= ky;
        if (source.x < 0) source.x = PM_GRID - 1;
        if (source.x >= PM_GRID) source.x = 0;
        if (source.y < 0) source.y = PM_GRID - 1;
        if (source.y >= PM_GRID) source.y = 0;
      }
    }

    function drawPacman() {
      ctx.fillStyle = "#000022";
      ctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);

      ctx.fillStyle = "#333366";
      for (let y = 0; y < PM_GRID; y++) {
        for (let x = 0; x < PM_GRID; x++) {
          ctx.fillRect(x * PM_TILE, y * PM_TILE, 1, 1);
        }
      }

      ctx.fillStyle = "#ffb";
      pacPellets.forEach(pe => {
        if (!pe.eaten) {
          ctx.beginPath();
          ctx.arc(
            pe.x * PM_TILE + PM_TILE / 2,
            pe.y * PM_TILE + PM_TILE / 2,
            2,
            0,
            Math.PI * 2
          );
          ctx.fill();
        }
      });

      pacGhosts.forEach(g => {
        ctx.fillStyle = g.color;
        ctx.fillRect(g.x * PM_TILE + 2, g.y * PM_TILE + 2, PM_TILE - 4, PM_TILE - 4);
      });

      pacPlayers.forEach(p => {
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(
          p.x * PM_TILE + PM_TILE / 2,
          p.y * PM_TILE + PM_TILE / 2,
          PM_TILE / 2 - 1,
          0,
          Math.PI * 2
        );
        ctx.fill();
      });

      ctx.fillStyle = "#fff";
      ctx.font = "10px system-ui";
      ctx.fillText("P1 Hearts: " + pacPlayers[0].hearts, 4, 10);
      ctx.fillText("P2 Hearts: " + pacPlayers[1].hearts, 4, 22);
    }

    function updatePacman() {
      if (!pacActive) return;
      pacTick++;
      if (pacTick % 4 === 0) {
        handlePacInput();
        movePacPlayers();
        eatPellets();
        moveGhosts();
        resolvePacCombat();
      }
    }

    // ===== GAME LOOP =====
    let currentGame = null;

    function loadGame(gameId) {
      currentGame = gameId;
      if (gameId === "snake") {
        resetSnake();
      } else if (gameId === "pacman") {
        resetPacman();
      } else {
        ctx.fillStyle = "#000";
        ctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);
        gameInfo.textContent = "Waiting for game selection…";
      }
    }

    function loop() {
      requestAnimationFrame(loop);
      if (currentGame === "snake") {
        updateSnake();
        drawSnake();
      } else if (currentGame === "pacman") {
        updatePacman();
        drawPacman();
      }
    }
    loop();

    // ===== INPUT HANDLING =====
    window.addEventListener("keydown", e => {
      if (currentGame === "snake") {
        if (e.key === "ArrowUp" && snakeDir.y !== 1) snakeDir = { x: 0, y: -1 };
        else if (e.key === "ArrowDown" && snakeDir.y !== -1) snakeDir = { x: 0, y: 1 };
        else if (e.key === "ArrowLeft" && snakeDir.x !== 1) snakeDir = { x: -1, y: 0 };
        else if (e.key === "ArrowRight" && snakeDir.x !== -1) snakeDir = { x: 1, y: 0 };
      } else if (currentGame === "pacman") {
        const p0 = pacPlayers[0];
        const p1 = pacPlayers[1];
        if (!p0 || !p1) return;

        if (e.key === "ArrowUp") { p0.input = { up: true, down: false, left: false, right: false }; }
        else if (e.key === "ArrowDown") { p0.input = { up: false, down: true, left: false, right: false }; }
        else if (e.key === "ArrowLeft") { p0.input = { up: false, down: false, left: true, right: false }; }
        else if (e.key === "ArrowRight") { p0.input = { up: false, down: false, left: false, right: true }; }

        if (e.key === "w") { p1.input = { up: true, down: false, left: false, right: false }; }
        else if (e.key === "s") { p1.input = { up: false, down: true, left: false, right: false }; }
        else if (e.key === "a") { p1.input = { up: false, down: false, left: true, right: false }; }
        else if (e.key === "d") { p1.input = { up: false, down: false, left: false, right: true }; }
      }
    });

    // ===== CHAT =====
    chatInput.addEventListener("keydown", e => {
      if (e.key === "Enter") {
        e.preventDefault();
        const text = chatInput.value.trim();
        if (!text || !currentRoomId) return;
        socket.emit("chat", {
          roomId: currentRoomId,
          text,
          from: nameInput.value.trim(),
          codename: deviceCodename
        });
        chatInput.value = "";
      }
    });
  </script>
</body>
</html>