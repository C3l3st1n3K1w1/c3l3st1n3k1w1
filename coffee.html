<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Bluetooth Game Hub + AI Bot</title>
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #05070b;
      color: #f5f5f5;
    }
    .app {
      max-width: 960px;
      margin: 0 auto;
      padding: 20px;
    }
    h1, h2, h3 {
      margin: 0 0 10px;
      font-weight: 600;
    }
    .small { font-size: 12px; color: #9ca3af; }
    .card {
      background: #0f172a;
      border-radius: 10px;
      border: 1px solid #1f2937;
      padding: 14px 16px;
      margin-top: 10px;
    }
    input, select {
      width: 100%;
      padding: 8px 10px;
      border-radius: 6px;
      border: 1px solid #374151;
      background: #020617;
      color: #e5e7eb;
      font-size: 14px;
    }
    label {
      display: block;
      margin-bottom: 4px;
      font-size: 13px;
    }
    button {
      border-radius: 8px;
      border: none;
      padding: 8px 14px;
      cursor: pointer;
      font-size: 14px;
      background: #2563eb;
      color: #f9fafb;
      display: inline-flex;
      align-items: center;
      gap: 4px;
      transition: background 0.12s, transform 0.07s;
    }
    button:disabled {
      background: #4b5563;
      cursor: not-allowed;
      transform: none;
    }
    button:not(:disabled):active {
      transform: scale(0.97);
    }
    .btn-secondary { background: #4b5563; }
    .btn-danger { background: #b91c1c; }
    .row { display: flex; gap: 10px; align-items: center; }
    .row.space-between { justify-content: space-between; }
    .mt-8 { margin-top: 8px; }
    .mt-12 { margin-top: 12px; }
    .mt-16 { margin-top: 16px; }
    .mt-20 { margin-top: 20px; }
    .menu-buttons {
      display: flex;
      gap: 10px;
      margin-bottom: 10px;
    }
    .menu-buttons button { flex: 1; }
    .error {
      color: #f97373;
      font-size: 12px;
      margin-top: 4px;
    }
    .hidden { display: none !important; }

    /* Modal */
    .modal-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.7);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }
    .modal {
      background: #020617;
      border-radius: 10px;
      border: 1px solid #374151;
      padding: 16px 18px 14px;
      max-width: 320px;
      width: 100%;
    }
    .modal-buttons {
      margin-top: 14px;
      display: flex;
      justify-content: flex-end;
      gap: 8px;
    }

    /* Lobby */
    .lobby-layout {
      display: grid;
      grid-template-columns: repeat(2, minmax(0,1fr));
      gap: 14px;
    }
    .player-card {
      text-align: center;
    }
    .pfp-circle {
      width: 72px;
      height: 72px;
      border-radius: 50%;
      background: #1f2937;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 38px;
      margin: 0 auto 8px;
    }
    .player-name {
      font-weight: 600;
      font-size: 15px;
      margin-bottom: 4px;
      word-break: break-word;
    }
    .device-emoji { font-size: 20px; }
    .status-text { font-size: 13px; color: #9ca3af; margin-top: 4px; }

    .games-dropdown { margin-top: 12px; }

    /* Game area */
    #gameContainer { margin-top: 10px; }

    /* Tic-Tac-Toe */
    .ttt-grid {
      display: grid;
      grid-template-columns: repeat(3,60px);
      grid-template-rows: repeat(3,60px);
      gap: 4px;
      justify-content: center;
      margin-top: 10px;
    }
    .ttt-cell {
      width: 60px;
      height: 60px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 28px;
      border-radius: 6px;
      background: #020617;
      cursor: pointer;
    }
    .ttt-cell.disabled { cursor: default; opacity: 0.5; }

    /* RPS */
    .rps-buttons {
      display: flex;
      gap: 10px;
      justify-content: center;
      margin-top: 10px;
    }

    /* Chess */
    .chess-board {
      display: grid;
      grid-template-columns: repeat(8, 40px);
      grid-template-rows: repeat(8, 40px);
      border: 2px solid #111827;
      margin-top: 10px;
    }
    .chess-square {
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      cursor: pointer;
      user-select: none;
    }
    .chess-light { background: #f9fafb11; }
    .chess-dark { background: #111827; }
    .chess-selected { outline: 2px solid #facc15; outline-offset: -2px; }

    /* Floating AI Bot button */
    #aiBotButton {
      position: fixed;
      right: 16px;
      bottom: 16px;
      z-index: 900;
      box-shadow: 0 10px 25px rgba(0,0,0,0.5);
    }
    #aiBotPanel {
      position: fixed;
      right: 16px;
      bottom: 70px;
      z-index: 900;
      width: 260px;
    }
  </style>
</head>
<body>
<div class="app">
  <h1>Bluetooth Game Hub</h1>
  <p class="small">no blutooth? no bluplay ¬∑ 2-player hub with optional ü§ñ AI bot mode.</p>

  <!-- MAIN SCREEN -->
  <div id="screen-main" class="card">
    <div class="menu-buttons">
      <button id="btnHost">üåêHost BluTooth</button>
      <button id="btnLocat">Locat BluToothüêà</button>
    </div>

    <div class="mt-8">
      <label for="nameInput">Name (required)</label>
      <input id="nameInput" type="text" placeholder="Your name (e.g. Rin @%)">
      <div id="nameError" class="error hidden"></div>
    </div>

    <div class="mt-12">
      <label for="emojiInput">PFP Emoji (required, emoji only)</label>
      <input id="emojiInput" type="text" placeholder="e.g. üò∫">
      <div id="emojiError" class="error hidden"></div>
    </div>

    <p class="small mt-12">
      Hint: If your name ends with <code> @%</code>, the <code>@%</code> part is hidden,
      but your device icon becomes üòé.
    </p>
    <p class="small mt-8">
      Real Web Bluetooth requires Android Chrome over HTTPS to actually show a system device picker.
    </p>
  </div>

  <!-- HOST LOBBY -->
  <div id="screen-host" class="hidden">
    <div class="row space-between mt-8">
      <h2>Host Lobby</h2>
      <button id="btnHostBack" class="btn-secondary">Back to Main</button>
    </div>
    <div class="card">
      <div class="lobby-layout">
        <div class="player-card">
          <h3>You (Host)</h3>
          <div class="pfp-circle" id="hostPfp"></div>
          <div class="player-name" id="hostName"></div>
          <div class="device-emoji" id="hostDevice"></div>
        </div>
        <div class="player-card">
          <h3>Guest</h3>
          <div class="pfp-circle" id="guestPfp">?</div>
          <div class="player-name" id="guestName">Waiting...</div>
          <div class="device-emoji" id="guestDevice"></div>
          <div class="status-text" id="guestStatus">Waiting for player to connect...</div>
        </div>
      </div>

      <div id="gamesSection" class="games-dropdown hidden">
        <label for="gameSelect">Select game</label>
        <select id="gameSelect">
          <option value="" disabled selected>Choose a game...</option>
          <option>Cookie Roulette</option>
          <option>Tic-Tac-Toe</option>
          <option>Rock-Paper-Scissors Battle</option>
          <option>Connect 4</option>
          <option>Micro-Battleship</option>
          <option>Wordle Duel</option>
          <option>Chess</option>
        </select>
        <div class="row space-between mt-12">
          <button id="btnStartGame">Start Game</button>
        </div>
      </div>

      <p class="small mt-12">
        Joiners must connect via Bluetooth. Once connected, the game list appears for you to choose.
      </p>
    </div>
  </div>

  <!-- JOIN SCREEN -->
  <div id="screen-join" class="hidden">
    <div class="row space-between mt-8">
      <h2>Locate BluTooth Host</h2>
      <button id="btnJoinBack" class="btn-secondary">Back to Main</button>
    </div>
    <div class="card">
      <div id="joinContent"></div>
    </div>
  </div>

  <!-- GAME SCREEN -->
  <div id="screen-game" class="hidden">
    <div class="row space-between mt-8">
      <h2 id="gameTitle">Game</h2>
      <button id="btnGameBack" class="btn-secondary">Back to Main</button>
    </div>
    <div class="card" id="gameContainer"></div>
  </div>
</div>

<!-- AI BOT BUTTON + PANEL -->
<button id="aiBotButton">ü§ñ AI Bot Mode</button>
<div id="aiBotPanel" class="hidden">
  <div class="card">
    <div class="row space-between">
      <strong>ü§ñ AI Bot Mode</strong>
      <button id="btnCloseAiPanel" class="btn-secondary" style="padding:2px 8px;font-size:12px;">√ó</button>
    </div>
    <p class="small mt-8">
      Play locally vs an AI bot. No Bluetooth required. Both sides use ü§ñ.
    </p>
    <label class="mt-8">Choose game vs AI</label>
    <select id="aiGameSelect">
      <option value="" disabled selected>Pick a game...</option>
      <option value="Tic-Tac-Toe">Tic-Tac-Toe (vs AI)</option>
      <option value="Rock-Paper-Scissors Battle">Rock-Paper-Scissors (vs AI)</option>
      <option value="Chess">Chess (simple AI)</option>
    </select>
    <button id="btnStartAiGame" class="mt-12">Play vs ü§ñ</button>
  </div>
</div>

<!-- BLUETOOTH MODAL -->
<div id="btModalBackdrop" class="modal-backdrop">
  <div class="modal">
    <h3>Bluetooth is off</h3>
    <p class="small mt-8">Turn it on to continue.</p>
    <div class="modal-buttons">
      <button id="btnBtCancel" class="btn-secondary">Cancel</button>
      <button id="btnBtOn">Turn On Bluetooth</button>
    </div>
  </div>
</div>

<script>
  // ---- GLOBAL STATE ----
  let btEnabled = false;
  let pendingAction = null; // "host" or "join"
  let hostSession = null;
  let guestSession = null;
  let currentGame = null;
  let gameMode = null; // "bt" or "ai"

  // ---- ELEMENTS ----
  const screenMain = document.getElementById("screen-main");
  const screenHost = document.getElementById("screen-host");
  const screenJoin = document.getElementById("screen-join");
  const screenGame = document.getElementById("screen-game");

  const btnHost = document.getElementById("btnHost");
  const btnLocat = document.getElementById("btnLocat");
  const nameInput = document.getElementById("nameInput");
  const emojiInput = document.getElementById("emojiInput");
  const nameError = document.getElementById("nameError");
  const emojiError = document.getElementById("emojiError");

  const btModalBackdrop = document.getElementById("btModalBackdrop");
  const btnBtOn = document.getElementById("btnBtOn");
  const btnBtCancel = document.getElementById("btnBtCancel");

  const hostPfp = document.getElementById("hostPfp");
  const hostNameEl = document.getElementById("hostName");
  const hostDeviceEl = document.getElementById("hostDevice");
  const guestPfp = document.getElementById("guestPfp");
  const guestNameEl = document.getElementById("guestName");
  const guestDeviceEl = document.getElementById("guestDevice");
  const guestStatusEl = document.getElementById("guestStatus");
  const gamesSection = document.getElementById("gamesSection");
  const gameSelect = document.getElementById("gameSelect");
  const btnStartGame = document.getElementById("btnStartGame");

  const btnHostBack = document.getElementById("btnHostBack");
  const btnJoinBack = document.getElementById("btnJoinBack");
  const btnGameBack = document.getElementById("btnGameBack");

  const joinContent = document.getElementById("joinContent");
  const gameTitle = document.getElementById("gameTitle");
  const gameContainer = document.getElementById("gameContainer");

  const aiBotButton = document.getElementById("aiBotButton");
  const aiBotPanel = document.getElementById("aiBotPanel");
  const btnCloseAiPanel = document.getElementById("btnCloseAiPanel");
  const aiGameSelect = document.getElementById("aiGameSelect");
  const btnStartAiGame = document.getElementById("btnStartAiGame");

  // ---- UTIL ----
  function showScreen(id) {
    screenMain.classList.add("hidden");
    screenHost.classList.add("hidden");
    screenJoin.classList.add("hidden");
    screenGame.classList.add("hidden");
    if (id === "main") screenMain.classList.remove("hidden");
    if (id === "host") screenHost.classList.remove("hidden");
    if (id === "join") screenJoin.classList.remove("hidden");
    if (id === "game") screenGame.classList.remove("hidden");
  }

  function detectDeviceEmoji() {
    const ua = navigator.userAgent || "";
    if (/Android|iPhone|iPad|iPod/i.test(ua)) return "üì±";
    if (/Windows|Macintosh|Linux/i.test(ua)) return "üíª";
    return "üì∫";
  }

  function parseName(rawName) {
    let cool = false;
    let displayName = rawName.trim();
    const match = rawName.match(/^(.*)\s@%$/);
    if (match) {
      cool = true;
      displayName = match[1].trim();
    }
    return { displayName, cool };
  }

  function validateInputs() {
    const rawName = nameInput.value.trim();
    const emojiValue = emojiInput.value.trim();

    let valid = true;
    nameError.classList.add("hidden");
    emojiError.classList.add("hidden");

    if (!rawName) {
      nameError.textContent = "You must enter a name.";
      nameError.classList.remove("hidden");
      valid = false;
    }
    if (!emojiValue) {
      emojiError.textContent = "You must enter an emoji for your profile picture.";
      emojiError.classList.remove("hidden");
      valid = false;
    } else {
      if (/[A-Za-z0-9]/.test(emojiValue)) {
        emojiError.textContent = "PFP input cannot contain letters or numbers. Use emoji only.";
        emojiError.classList.remove("hidden");
        valid = false;
      }
    }
    return valid;
  }

  function openBtModal(action) {
    pendingAction = action;
    btModalBackdrop.style.display = "flex";
  }

  function closeBtModal() {
    btModalBackdrop.style.display = "none";
    pendingAction = null;
  }

  // ---- BLUETOOTH ----
  async function tryRealBluetoothScan() {
    if (!navigator.bluetooth) {
      console.warn("Web Bluetooth not supported.");
      return null;
    }
    try {
      const device = await navigator.bluetooth.requestDevice({
        acceptAllDevices: true
      });
      return device;
    } catch (e) {
      console.warn("Bluetooth scan cancelled or failed:", e);
      return null;
    }
  }

  // ---- HOST FLOW ----
  function doHostFlow() {
    if (!validateInputs()) return;
    const rawName = nameInput.value.trim();
    const emojiValue = emojiInput.value.trim();
    const { displayName, cool } = parseName(rawName);
    const deviceEmoji = cool ? "üòé" : detectDeviceEmoji();

    hostSession = { rawName, displayName, emoji: emojiValue, deviceEmoji };
    guestSession = null;

    hostPfp.textContent = emojiValue;
    hostNameEl.textContent = displayName || "(unnamed)";
    hostDeviceEl.textContent = deviceEmoji;

    guestPfp.textContent = "?";
    guestNameEl.textContent = "Waiting...";
    guestDeviceEl.textContent = "";
    guestStatusEl.textContent = "Waiting for player to connect...";
    gamesSection.classList.add("hidden");
    gameSelect.value = "";

    showScreen("host");
  }

  // ---- JOIN FLOW ----
  async function doJoinFlow() {
    if (!validateInputs()) return;

    joinContent.innerHTML = "<p class='small'>Scanning for hosts using Web Bluetooth...</p>";

    const device = await tryRealBluetoothScan();
    if (!device) {
      joinContent.innerHTML += "<p class='small mt-8'>Scan cancelled or no device selected.</p>";
      showScreen("join");
      return;
    }

    if (!hostSession) {
      joinContent.innerHTML = `
        <p>No BluTooth hosts found in this hub session.</p>
        <p class="small mt-8">Another device must press "üåêHost BluTooth" to appear as a host.</p>
      `;
      showScreen("join");
      return;
    }

    const rawName = nameInput.value.trim();
    const emojiValue = emojiInput.value.trim();
    const { displayName, cool } = parseName(rawName);
    const deviceEmoji = cool ? "üòé" : detectDeviceEmoji();

    guestSession = { rawName, displayName, emoji: emojiValue, deviceEmoji };

    joinContent.innerHTML = `
      <p>Connected to host: <strong>${hostSession.displayName}</strong></p>
      <p class="small mt-8">The host will select a game. You will follow automatically.</p>
    `;

    guestPfp.textContent = emojiValue;
    guestNameEl.textContent = displayName || "(guest)";
    guestDeviceEl.textContent = deviceEmoji;
    guestStatusEl.textContent = "Connected";

    gamesSection.classList.remove("hidden");
    showScreen("host");
  }

  // ---- BUTTON HANDLERS ----
  btnHost.addEventListener("click", () => {
    if (!btEnabled) {
      openBtModal("host");
      return;
    }
    doHostFlow();
  });

  btnLocat.addEventListener("click", () => {
    if (!btEnabled) {
      openBtModal("join");
      return;
    }
    doJoinFlow();
  });

  btnBtOn.addEventListener("click", () => {
    btEnabled = true;
    const action = pendingAction;
    closeBtModal();
    if (action === "host") doHostFlow();
    if (action === "join") doJoinFlow();
  });

  btnBtCancel.addEventListener("click", () => {
    closeBtModal();
  });

  btnHostBack.addEventListener("click", () => {
    showScreen("main");
  });

  btnJoinBack.addEventListener("click", () => {
    showScreen("main");
  });

  btnGameBack.addEventListener("click", () => {
    currentGame = null;
    gameMode = null;
    gameContainer.innerHTML = "";
    showScreen("main");
  });

  btnStartGame.addEventListener("click", () => {
    const sel = gameSelect.value;
    if (!sel) return;
    currentGame = sel;
    gameMode = "bt";
    startGame(sel, "bt");
  });

  // ---- AI BOT MODE ----
  aiBotButton.addEventListener("click", () => {
    aiBotPanel.classList.toggle("hidden");
  });
  btnCloseAiPanel.addEventListener("click", () => {
    aiBotPanel.classList.add("hidden");
  });
  btnStartAiGame.addEventListener("click", () => {
    const sel = aiGameSelect.value;
    if (!sel) return;
    currentGame = sel;
    gameMode = "ai";
    aiBotPanel.classList.add("hidden");
    startGame(sel, "ai");
  });

  // ---- GAME LAUNCHER ----
  function startGame(name, mode) {
    gameTitle.textContent = name + (mode === "ai" ? " ¬∑ vs ü§ñ" : " ¬∑ Bluetooth match");
    gameContainer.innerHTML = "";
    showScreen("game");

    if (name === "Tic-Tac-Toe") initTicTacToe(mode);
    else if (name === "Rock-Paper-Scissors Battle") initRps(mode);
    else if (name === "Chess") initChess(mode);
    else initSimpleTextGame(name, mode);
  }

  // Fallback for games without detailed implementation
  function initSimpleTextGame(name, mode) {
    const div = document.createElement("div");
    div.innerHTML = `
      <p>${name} is loaded in ${mode === "ai" ? "AI" : "Bluetooth"} mode.</p>
      <p class="small mt-8">
        Basic UI only for now. AI is not implemented for this game yet,
        but you can still use this as a placeholder to expand later.
      </p>
    `;
    gameContainer.appendChild(div);
  }

  // ---- TIC-TAC-TOE ----
  function initTicTacToe(mode) {
    const status = document.createElement("p");
    status.className = "small";
    status.textContent = "X to move.";
    const grid = document.createElement("div");
    grid.className = "ttt-grid";

    const cells = Array(9).fill("");
    let current = "X";
    let finished = false;
    const vsAI = (mode === "ai");

    function checkWinner(b) {
      const lines = [
        [0,1,2],[3,4,5],[6,7,8],
        [0,3,6],[1,4,7],[2,5,8],
        [0,4,8],[2,4,6]
      ];
      for (const [a,b2,c] of lines) {
        if (b[a] && b[a] === b[b2] && b[a] === b[c]) return b[a];
      }
      if (b.every(x => x)) return "draw";
      return null;
    }

    function render() {
      grid.innerHTML = "";
      cells.forEach((val, idx) => {
        const cell = document.createElement("div");
        cell.className = "ttt-cell" + (finished ? " disabled" : "");
        cell.textContent = val;
        cell.addEventListener("click", () => {
          if (finished || cells[idx]) return;
          if (vsAI && current === "O") return;
          cells[idx] = current;
          const res = checkWinner(cells);
          if (res) {
            finished = true;
            status.textContent = res === "draw" ? "Draw game." : res + " wins.";
            render();
            return;
          }
          current = (current === "X" ? "O" : "X");
          status.textContent = current + " to move.";
          render();
          if (vsAI && current === "O" && !finished) {
            setTimeout(aiMove, 300);
          }
        });
        grid.appendChild(cell);
      });
    }

    function aiMove() {
      // Simple: try to win, then block, else random
      const emptyIdx = cells.map((v,i) => v ? null : i).filter(v => v !== null);
      if (!emptyIdx.length) return;
      function tryLine(mark) {
        for (const [a,b,c] of [[0,1,2],[3,4,5],[6,7,8],[0,3,6],[1,4,7],[2,5,8],[0,4,8],[2,4,6]]) {
          const line = [cells[a], cells[b], cells[c]];
          if (line.filter(x=>x===mark).length === 2 && line.includes("")) {
            const idx = [a,b,c][line.indexOf("")];
            return idx;
          }
        }
        return null;
      }
      let idx = tryLine("O");
      if (idx === null) idx = tryLine("X");
      if (idx === null) idx = emptyIdx[Math.floor(Math.random()*emptyIdx.length)];
      cells[idx] = "O";
      const res = checkWinner(cells);
      if (res) {
        finished = true;
        status.textContent = res === "draw" ? "Draw game." : res + " wins.";
        render();
        return;
      }
      current = "X";
      status.textContent = "X to move.";
      render();
    }

    gameContainer.appendChild(status);
    gameContainer.appendChild(grid);
    render();
    if (vsAI && current === "O") aiMove();
  }

  // ---- ROCK-PAPER-SCISSORS ----
  function initRps(mode) {
    const vsAI = (mode === "ai");
    const status = document.createElement("p");
    status.textContent = vsAI ?
      "Choose Rock, Paper, or Scissors vs ü§ñ." :
      "Use this screen for Rock-Paper-Scissors; track wins manually.";
    const result = document.createElement("p");
    result.className = "small mt-8";
    const btnRow = document.createElement("div");
    btnRow.className = "rps-buttons";
    const options = ["Rock","Paper","Scissors"];

    options.forEach(opt => {
      const btn = document.createElement("button");
      btn.textContent = opt;
      btn.addEventListener("click", () => {
        if (!vsAI) {
          result.textContent = "In Bluetooth mode, both players pick and compare together.";
          return;
        }
        const aiChoice = options[Math.floor(Math.random()*options.length)];
        let outcome = "";
        if (opt === aiChoice) outcome = "It's a draw.";
        else if (
          (opt === "Rock" && aiChoice === "Scissors") ||
          (opt === "Paper" && aiChoice === "Rock") ||
          (opt === "Scissors" && aiChoice === "Paper")
        ) outcome = "You win!";
        else outcome = "ü§ñ wins.";
        result.textContent = `You: ${opt} ¬∑ ü§ñ: ${aiChoice} ¬∑ ${outcome}`;
      });
      btnRow.appendChild(btn);
    });

    gameContainer.appendChild(status);
    gameContainer.appendChild(btnRow);
    gameContainer.appendChild(result);
  }

  // ---- CHESS (simple board + random AI) ----
  function initChess(mode) {
    const vsAI = (mode === "ai");
    const status = document.createElement("p");
    status.className = "small";
    status.textContent = "White to move.";
    const boardEl = document.createElement("div");
    boardEl.className = "chess-board";

    // very simple piece set using Unicode
    // uppercase = white, lowercase = black
    let board = [
      ["r","n","b","q","k","b","n","r"],
      ["p","p","p","p","p","p","p","p"],
      ["","","","","","","",""],
      ["","","","","","","",""],
      ["","","","","","","",""],
      ["","","","","","","",""],
      ["P","P","P","P","P","P","P","P"],
      ["R","N","B","Q","K","B","N","R"]
    ];
    const pieceChar = {
      "P":"‚ôô","R":"‚ôñ","N":"‚ôò","B":"‚ôó","Q":"‚ôï","K":"‚ôî",
      "p":"‚ôü","r":"‚ôú","n":"‚ôû","b":"‚ôù","q":"‚ôõ","k":"‚ôö"
    };
    let selected = null;
    let whiteToMove = true;
    let finished = false;

    function inBounds(r,c){ return r>=0 && r<8 && c>=0 && c<8; }

    function isWhite(piece){ return piece && piece === piece.toUpperCase(); }
    function isBlack(piece){ return piece && piece === piece.toLowerCase(); }

    // extremely simplified move generation (no check detection, no castling, no en passant)
    function generateMoves(r,c) {
      const moves = [];
      const piece = board[r][c];
      if (!piece) return moves;
      const white = isWhite(piece);
      if (white !== whiteToMove) return moves;

      const directions = {
        "P":[[-1,0]], "p":[[1,0]],
        "R":[[1,0],[-1,0],[0,1],[0,-1]],
        "r":[[1,0],[-1,0],[0,1],[0,-1]],
        "B":[[1,1],[1,-1],[-1,1],[-1,-1]],
        "b":[[1,1],[1,-1],[-1,1],[-1,-1]],
        "Q":[[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]],
        "q":[[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]],
        "K":[[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]],
        "k":[[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]],
      };
      const knightMoves = [[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]];

      if (piece === "P" || piece === "p") {
        const step = piece === "P" ? -1 : 1;
        const startRow = piece === "P" ? 6 : 1;
        if (inBounds(r+step,c) && !board[r+step][c]) moves.push([r+step,c]);
        if (r === startRow && inBounds(r+2*step,c) && !board[r+step][c] && !board[r+2*step][c])
          moves.push([r+2*step,c]);
        const captures = [[step,-1],[step,1]];
        for (const [dr,dc] of captures) {
          const nr=r+dr,nc=c+dc;
          if (!inBounds(nr,nc)) continue;
          const target = board[nr][nc];
          if (target && (white ? isBlack(target) : isWhite(target))) moves.push([nr,nc]);
        }
      } else if (piece.toUpperCase() === "N") {
        for (const [dr,dc] of knightMoves) {
          const nr=r+dr,nc=c+dc;
          if (!inBounds(nr,nc)) continue;
          const target = board[nr][nc];
          if (!target || (white ? isBlack(target) : isWhite(target))) moves.push([nr,nc]);
        }
      } else if ("RBQrbq".includes(piece)) {
        const dirs = directions[piece];
        const sliding = piece.toUpperCase() !== "K";
        for (const [dr,dc] of dirs) {
          let nr=r+dr,nc=c+dc;
          while (inBounds(nr,nc)) {
            const target = board[nr][nc];
            if (!target) {
              moves.push([nr,nc]);
            } else {
              if (white ? isBlack(target) : isWhite(target)) moves.push([nr,nc]);
              break;
            }
            if (!sliding) break;
            nr+=dr; nc+=dc;
          }
        }
      } else if (piece.toUpperCase() === "K") {
        const dirs = directions[piece];
        for (const [dr,dc] of dirs) {
          const nr=r+dr,nc=c+dc;
          if (!inBounds(nr,nc)) continue;
          const target = board[nr][nc];
          if (!target || (white ? isBlack(target) : isWhite(target))) moves.push([nr,nc]);
        }
      }
      return moves;
    }

    function renderBoard() {
      boardEl.innerHTML = "";
      for (let r=0;r<8;r++) {
        for (let c=0;c<8;c++) {
          const sq = document.createElement("div");
          sq.className = "chess-square " + ((r+c)%2===0 ? "chess-light" : "chess-dark");
          const piece = board[r][c];
          if (piece) sq.textContent = pieceChar[piece] || "";
          if (!finished) {
            sq.addEventListener("click", () => onSquareClick(r,c,sq));
          }
          if (selected && selected.r === r && selected.c === c) {
            sq.classList.add("chess-selected");
          }
          boardEl.appendChild(sq);
        }
      }
    }

    function onSquareClick(r,c) {
      if (finished) return;
      const piece = board[r][c];
      if (selected) {
        const moves = generateMoves(selected.r, selected.c);
        const isMove = moves.some(([mr,mc]) => mr===r && mc===c);
        if (isMove) {
          board[r][c] = board[selected.r][selected.c];
          board[selected.r][selected.c] = "";
          selected = null;
          whiteToMove = !whiteToMove;
          status.textContent = whiteToMove ? "White to move." : "Black to move.";
          renderBoard();
          if (!whiteToMove && vsAI) {
            setTimeout(aiMoveChess, 300);
          }
          return;
        } else {
          selected = null;
          renderBoard();
          return;
        }
      } else {
        if (!piece) return;
        const whitePiece = isWhite(piece);
        if (whitePiece !== whiteToMove) return;
        selected = { r, c };
        renderBoard();
      }
    }

    function collectAllMoves(forWhite) {
      const moves = [];
      for (let r=0;r<8;r++) {
        for (let c=0;c<8;c++) {
          const piece = board[r][c];
          if (!piece) continue;
          if (forWhite ? isWhite(piece) : isBlack(piece)) {
            const ms = generateMoves(r,c);
            ms.forEach(([mr,mc]) => moves.push({from:{r,c},to:{r:mr,c:mc}}));
          }
        }
      }
      return moves;
    }

    function aiMoveChess() {
      if (finished) return;
      const allMoves = collectAllMoves(false); // black moves
      if (!allMoves.length) {
        status.textContent = "No moves for black. Game over-ish.";
        finished = true;
        return;
      }
      const mv = allMoves[Math.floor(Math.random()*allMoves.length)];
      const piece = board[mv.from.r][mv.from.c];
      board[mv.to.r][mv.to.c] = piece;
      board[mv.from.r][mv.from.c] = "";
      whiteToMove = true;
      status.textContent = "White to move.";
      renderBoard();
    }

    gameContainer.appendChild(status);
    gameContainer.appendChild(boardEl);
    renderBoard();
    if (!whiteToMove && vsAI) aiMoveChess();
  }

  // ---- INIT ----
  showScreen("main");
</script>
</body>
</html>